<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover" />
  <title>MR Studio - Pro Touch</title>
  <style>
    /* === ESTILO APPLE (CLEAN UI) === */
    body { 
      margin: 0; background: #f5f5f7; overflow: hidden; 
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      -webkit-user-select: none; user-select: none; touch-action: none; 
      color: #1d1d1f;
    }
    
    /* Overlay Inicial */
    #overlay {
      position: absolute; inset: 0; display: flex; flex-direction: column;
      justify-content: center; align-items: center; 
      background: rgba(255,255,255,0.95); backdrop-filter: blur(25px);
      z-index: 999; transition: opacity 0.5s ease;
    }
    button.start-btn {
      padding: 18px 45px; font-size: 18px; 
      background: #007AFF; border: none; border-radius: 50px; 
      color: white; font-weight: 600; letter-spacing: 0.5px;
      box-shadow: 0 8px 20px rgba(0, 122, 255, 0.25);
      cursor: pointer;
    }

    /* Selector de Modos (Top) */
    #render-bar {
      position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
      display: flex; background: rgba(235, 235, 240, 0.9);
      padding: 4px; border-radius: 12px; z-index: 100;
      box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    }
    .render-opt {
      padding: 8px 16px; font-size: 13px; font-weight: 500;
      border-radius: 8px; border: none; background: transparent;
      color: #888; transition: 0.2s;
    }
    .render-opt.active { background: #fff; color: #000; box-shadow: 0 2px 5px rgba(0,0,0,0.1); font-weight: 600; }

    /* Barra Herramientas (Bottom) */
    #toolbar {
      position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 15px; padding: 15px 25px;
      background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(20px);
      border-radius: 28px; border: 1px solid rgba(255,255,255,0.5);
      box-shadow: 0 10px 40px rgba(0,0,0,0.1); z-index: 100;
    }

    .tool-btn {
      width: 56px; height: 56px; border-radius: 18px; border: none;
      background: rgba(240, 240, 245, 0.5); color: #333; font-size: 24px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      transition: all 0.2s;
    }
    .tool-btn:active { transform: scale(0.92); }
    .tool-btn.active { background: #007AFF; color: white; box-shadow: 0 5px 15px rgba(0,122,255,0.3); }
    .btn-delete { color: #FF3B30; } 
    .btn-delete:active { background: #FF3B30; color: white; }
    
    .label { font-size: 9px; margin-top: 3px; font-weight: 600; opacity: 0.9; }

    /* Aviso flotante */
    #toast {
      position: absolute; top: 110px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.7); color: white; padding: 8px 16px;
      border-radius: 20px; font-size: 12px; pointer-events: none;
      opacity: 0; transition: opacity 0.3s;
    }
  </style>
</head>
<body>

<div id="overlay">
  <h1 style="margin-bottom:10px; font-weight:800; font-size:32px;">MR STUDIO</h1>
  <p style="color:#888; margin-top:0; margin-bottom:40px;">Edici√≥n T√°ctil de Precisi√≥n</p>
  <button class="start-btn" id="btn-start">Comenzar</button>
</div>

<div id="render-bar">
  <button class="render-opt active" onclick="setRenderMode('flat')">Plano</button>
  <button class="render-opt" onclick="setRenderMode('lightmap')">Suave</button>
  <button class="render-opt" onclick="setRenderMode('workbench')">Tech</button>
</div>

<div id="toast">Doble toque para seleccionar</div>

<div id="toolbar">
  <button class="tool-btn" onclick="spawn('box')">üì¶<span class="label">Cubo</span></button>
  <button class="tool-btn" onclick="spawn('sphere')">‚ö™<span class="label">Esfera</span></button>
  <div style="width:1px; background:#ddd; margin:0 5px;"></div>
  <button class="tool-btn active" id="btn-move" onclick="setMode('translate')">‚ÜîÔ∏è<span class="label">Mover</span></button>
  <button class="tool-btn" id="btn-rot" onclick="setMode('rotate')">üîÑ<span class="label">Rotar</span></button>
  <button class="tool-btn" id="btn-scale" onclick="setMode('scale')">üîç<span class="label">Escala</span></button>
  <div style="width:1px; background:#ddd; margin:0 5px;"></div>
  <button class="tool-btn btn-delete" onclick="del()">üóëÔ∏è<span class="label">Borrar</span></button>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { TransformControls } from 'three/addons/controls/TransformControls.js';

// === CONFIGURACI√ìN VISUAL ===
const CFG = {
  bg: 0xf5f5f7,
  gridMain: 0xd1d1d6,
  gridSub: 0xe5e5ea,
  objColor: 0xdbe4eb, // Gris celeste
  objEdge: 0xffffff,
  selColor: 0x007AFF
};

let scene, camera, renderer, orbit, control;
const objects = [];
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let currentRenderMode = 'flat';
let gridTexture = null;

// Variables Touch
let lastTap = 0;
let startX = 0, startY = 0;

init();
animate();

function init() {
  // 1. Scene Setup
  scene = new THREE.Scene();
  scene.background = new THREE.Color(CFG.bg);
  scene.fog = new THREE.Fog(CFG.bg, 15, 50);

  // 2. Camera (FOV ajustado para m√≥vil)
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(4, 3, 5);

  // 3. Renderer High-DPI
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Retinar display support
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // 4. Luces de Estudio
  const hemi = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(5, 10, 7);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048, 2048);
  scene.add(dir);

  // 5. Grid Infinita
  const grid = new THREE.GridHelper(40, 40, CFG.gridMain, CFG.gridSub);
  scene.add(grid);

  // 6. Textura Procedural para modo "Tech"
  gridTexture = createTechTexture();

  // 7. ORBIT CONTROLS (AJUSTE FINO DE ZOOM)
  orbit = new OrbitControls(camera, renderer.domElement);
  orbit.enableDamping = true; // Inercia suave
  orbit.dampingFactor = 0.05; // Sensaci√≥n de peso
  orbit.zoomSpeed = 0.5; // Zoom m√°s lento y preciso
  orbit.rotateSpeed = 0.7; // Rotaci√≥n controlada
  orbit.maxPolarAngle = Math.PI / 2 - 0.05; // No pasar el suelo
  orbit.minDistance = 1; // No entrar en el objeto
  orbit.maxDistance = 20;

  // 8. TRANSFORM CONTROLS (GIZMO RELEVANTE)
  control = new TransformControls(camera, renderer.domElement);
  control.setSize(1.6); // GIZMO GRANDE para dedos
  control.space = 'local';
  
  // LOGICA CR√çTICA: Desactivar √≥rbita al tocar Gizmo
  control.addEventListener('dragging-changed', (event) => {
    orbit.enabled = !event.value; // Bloquea c√°mara si mueves objeto
  });
  
  // Hack visual: Engrosar las l√≠neas del Gizmo para que se vean mejor
  // (Esto se aplica internamente en Threejs, aumentamos el tama√±o base arriba)
  
  scene.add(control);

  // Eventos
  window.addEventListener('resize', onResize);
  setupTouchEvents();

  // Start UI
  document.getElementById('btn-start').addEventListener('click', () => {
    document.getElementById('overlay').style.opacity = 0;
    setTimeout(() => {
      document.getElementById('overlay').style.display = 'none';
      showToast();
    }, 500);
    spawn('box');
  });

  // Global functions
  window.spawn = spawn;
  window.setMode = setMode;
  window.del = del;
  window.setRenderMode = setRenderMode;
}

// === GESTI√ìN T√ÅCTIL (DOBLE TOQUE) ===
function setupTouchEvents() {
  const canvas = renderer.domElement;
  
  canvas.addEventListener('pointerdown', (e) => {
    startX = e.clientX; 
    startY = e.clientY;
  });

  canvas.addEventListener('pointerup', (e) => {
    // Si estamos arrastrando el gizmo, ignorar
    if (control.dragging) return;

    // Calcular desplazamiento
    const dist = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
    
    // Si movi√≥ menos de 10px, es un "Tap"
    if (dist < 10) {
      const now = Date.now();
      if (now - lastTap < 300) {
        // DOBLE TOQUE CONFIRMADO
        checkSelection(e.clientX, e.clientY);
        lastTap = 0;
      } else {
        lastTap = now;
      }
    }
  });
}

function checkSelection(x, y) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((y - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(objects, false);

  if (intersects.length > 0) {
    attachGizmo(intersects[0].object);
  } else {
    detachGizmo();
  }
}

function attachGizmo(obj) {
  control.attach(obj);
  // Feedback visual en bordes
  objects.forEach(o => {
    if(o.userData.edges) o.userData.edges.material.color.setHex(CFG.objEdge);
  });
  if(obj.userData.edges) obj.userData.edges.material.color.setHex(CFG.selColor);
}

function detachGizmo() {
  control.detach();
  objects.forEach(o => {
    if(o.userData.edges) o.userData.edges.material.color.setHex(CFG.objEdge);
  });
}

// === CREACI√ìN DE OBJETOS ===
function spawn(type) {
  let geo;
  if(type === 'box') geo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
  else geo = new THREE.SphereGeometry(0.7, 48, 48);

  const mat = new THREE.MeshStandardMaterial({
    color: CFG.objColor,
    roughness: 0.4, metalness: 0.1
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = true; mesh.receiveShadow = true;
  mesh.position.y = 0.6;
  mesh.position.x = (Math.random()-0.5)*3;
  mesh.position.z = (Math.random()-0.5)*3;

  // Bordes est√©ticos
  const edgesGeo = new THREE.EdgesGeometry(geo);
  const edgesMat = new THREE.LineBasicMaterial({ color: CFG.objEdge, transparent:true, opacity:0.4 });
  const edges = new THREE.LineSegments(edgesGeo, edgesMat);
  mesh.add(edges);
  mesh.userData.edges = edges;

  scene.add(mesh);
  objects.push(mesh);
  
  applyRenderMode(mesh, currentRenderMode);
  attachGizmo(mesh);
}

// === RENDER MODES ===
function createTechTexture() {
  const c = document.createElement('canvas');
  c.width = 512; c.height = 512;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#eee'; ctx.fillRect(0,0,512,512);
  ctx.strokeStyle = '#ccc'; ctx.lineWidth=2;
  ctx.beginPath();
  for(let i=0;i<=512;i+=64){
    ctx.moveTo(i,0); ctx.lineTo(i,512);
    ctx.moveTo(0,i); ctx.lineTo(512,i);
  }
  ctx.stroke();
  const t = new THREE.CanvasTexture(c);
  t.wrapS = t.wrapT = THREE.RepeatWrapping;
  return t;
}

function setRenderMode(mode) {
  currentRenderMode = mode;
  document.querySelectorAll('.render-opt').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
  objects.forEach(o => applyRenderMode(o, mode));
}

function applyRenderMode(mesh, mode) {
  const m = mesh.material;
  const e = mesh.userData.edges;
  
  if (mode === 'flat') {
    m.map = null; m.roughness = 0.4; m.flatShading = false; m.color.setHex(CFG.objColor);
    if(e) e.visible = true;
  } 
  else if (mode === 'lightmap') {
    m.map = null; m.roughness = 1; m.color.setHex(0xccced0); // Arcilla
    if(e) e.visible = false;
  }
  else if (mode === 'workbench') {
    m.map = gridTexture; m.roughness = 0.5; m.color.setHex(0xffffff);
    if(e) e.visible = true;
  }
  m.needsUpdate = true;
}

// === TOOLS ===
function setMode(mode) {
  control.setMode(mode);
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
  const map = {translate:'btn-move', rotate:'btn-rot', scale:'btn-scale'};
  document.getElementById(map[mode]).classList.add('active');
}

function del() {
  if(control.object) {
    const o = control.object;
    control.detach();
    scene.remove(o);
    objects.splice(objects.indexOf(o), 1);
  }
}

function showToast() {
  const t = document.getElementById('toast');
  t.style.opacity = 1;
  setTimeout(()=> t.style.opacity=0, 4000);
}

function onResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  orbit.update();
  renderer.render(scene, camera);
}
</script>
</body>
</html>
