<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover" />
  <title>MR Studio Final</title>
  <style>
    /* === ESTILOS UI (APPLE STYLE) === */
    body { 
      margin: 0; background: #f2f2f7; overflow: hidden; 
      font-family: -apple-system, "SF Pro Text", sans-serif;
      -webkit-user-select: none; user-select: none; touch-action: none; 
      color: #1c1c1e;
    }
    
    #overlay {
      position: absolute; inset: 0; display: flex; flex-direction: column;
      justify-content: center; align-items: center; 
      background: rgba(255,255,255,0.95); backdrop-filter: blur(25px);
      z-index: 999; transition: opacity 0.4s ease;
    }
    h1 { font-weight: 800; font-size: 32px; margin: 0 0 10px 0; letter-spacing: -1px; }
    p { color: #8e8e93; margin: 0 0 40px 0; font-weight: 500; text-align: center; max-width: 80%; }
    
    button.start-btn {
      padding: 16px 48px; font-size: 18px; 
      background: #FF9500; border: none; border-radius: 40px; 
      color: white; font-weight: 700;
      box-shadow: 0 8px 25px rgba(255, 149, 0, 0.35);
      cursor: pointer; transform: scale(1); transition: 0.2s;
    }
    button.start-btn:active { transform: scale(0.96); }

    #render-bar {
      position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
      display: flex; background: rgba(255, 255, 255, 0.9);
      padding: 4px; border-radius: 14px; z-index: 100;
      backdrop-filter: blur(20px);
      box-shadow: 0 4px 15px rgba(0,0,0,0.08);
      border: 1px solid rgba(255,255,255,0.4);
    }
    .render-opt {
      padding: 8px 20px; font-size: 13px; font-weight: 600;
      border-radius: 10px; border: none; background: transparent;
      color: #999; transition: 0.2s;
    }
    .render-opt.active { background: #fff; color: #000; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }

    #toolbar-container {
      position: absolute; bottom: 35px; left: 0; right: 0;
      display: flex; justify-content: center; pointer-events: none; z-index: 100;
    }
    #toolbar {
      pointer-events: auto; display: flex; gap: 12px; padding: 12px 16px;
      background: rgba(255, 255, 255, 0.9); 
      backdrop-filter: blur(30px);
      border-radius: 28px; border: 1px solid rgba(255,255,255,0.5);
      box-shadow: 0 15px 40px rgba(0,0,0,0.15);
      max-width: 90%; overflow-x: auto; scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch; scrollbar-width: none;
    }
    .tool-btn {
      flex-shrink: 0; width: 56px; height: 56px; border-radius: 18px; border: none;
      background: rgba(235, 235, 240, 0.6); color: #1c1c1e; font-size: 26px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      transition: 0.2s;
    }
    .tool-btn.active { background: #FF9500; color: white; box-shadow: 0 6px 15px rgba(255, 149, 0, 0.3); }
    .btn-delete { color: #FF3B30; }
    .label { font-size: 9px; margin-top: 3px; font-weight: 700; opacity: 0.7; }
    .divider { width: 1px; background: rgba(0,0,0,0.1); margin: 0 4px; flex-shrink: 0; }
    
    /* === SISTEMA DE MEDICI√ìN === */
    #measurement-line {
      position: absolute;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 150;
    }
    
    #measurement-line.visible {
      opacity: 1;
    }
    
    #distance-label {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 8px 16px;
      border-radius: 16px;
      font-size: 14px;
      font-weight: 700;
      font-family: 'SF Mono', 'Monaco', monospace;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 200;
      cursor: pointer;
      white-space: nowrap;
    }
    
    #distance-label.visible {
      opacity: 1;
    }
    
    #distance-label:active {
      background: rgba(255, 149, 0, 0.9);
    }
    
    /* === POP-UP DE CONFIRMACI√ìN === */
    #confirm-dialog {
      position: absolute;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(20px);
      padding: 20px 24px;
      border-radius: 24px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      z-index: 300;
      display: none;
      flex-direction: column;
      gap: 12px;
      min-width: 280px;
    }
    
    #confirm-dialog.visible {
      display: flex;
    }
    
    #confirm-dialog h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
      text-align: center;
      color: #1c1c1e;
    }
    
    #confirm-dialog .buttons {
      display: flex;
      gap: 12px;
    }
    
    #confirm-dialog button {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 14px;
      font-weight: 600;
      font-size: 15px;
      cursor: pointer;
      transition: 0.2s;
    }
    
    #confirm-dialog .btn-continue {
      background: #FF9500;
      color: white;
    }
    
    #confirm-dialog .btn-finish {
      background: #34C759;
      color: white;
    }
    
    #confirm-dialog button:active {
      transform: scale(0.96);
    }
    
    #distance-input-dialog {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(20px);
      padding: 24px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      z-index: 300;
      display: none;
    }
    
    #distance-input-dialog.visible {
      display: block;
    }
    
    #distance-input-dialog h3 {
      margin: 0 0 16px 0;
      font-size: 18px;
      font-weight: 700;
    }
    
    #distance-input-dialog input {
      width: 100%;
      padding: 12px;
      font-size: 24px;
      font-weight: 700;
      text-align: center;
      border: 2px solid #FF9500;
      border-radius: 12px;
      font-family: 'SF Mono', 'Monaco', monospace;
      margin-bottom: 16px;
    }
    
    #distance-input-dialog button {
      width: 48%;
      padding: 12px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 16px;
      cursor: pointer;
    }
    
    #distance-input-dialog .btn-apply {
      background: #FF9500;
      color: white;
      margin-right: 4%;
    }
    
    #distance-input-dialog .btn-cancel {
      background: #e5e5ea;
      color: #1c1c1e;
    }
    
    .tap-indicator {
      position: absolute; width: 40px; height: 40px; border-radius: 50%;
      background: rgba(255, 149, 0, 0.4); transform: translate(-50%, -50%);
      pointer-events: none; animation: pop 0.4s ease-out forwards; z-index: 9999;
    }
    @keyframes pop { to { transform: translate(-50%, -50%) scale(1.5); opacity: 0; } }
  </style>
</head>
<body>

<div id="overlay">
  <h1>MR STUDIO FINAL</h1>
  <p>Flechas 3D Visibles ‚Ä¢ Objeto Naranja ‚Ä¢ Pop-up Confirmaci√≥n</p>
  <button class="start-btn" id="btn-start">Comenzar</button>
</div>

<div id="render-bar">
  <button class="render-opt active" onclick="setRenderMode('flat', this)">Plano</button>
  <button class="render-opt" onclick="setRenderMode('lightmap', this)">Clay</button>
  <button class="render-opt" onclick="setRenderMode('workbench', this)">Tech</button>
</div>

<svg id="measurement-line" width="100%" height="100%" style="position: absolute; top: 0; left: 0;">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
      <polygon points="0 0, 10 5, 0 10" fill="#FF9500" />
    </marker>
  </defs>
  <line id="measure-line" x1="0" y1="0" x2="0" y2="0" 
        stroke="#FF9500" stroke-width="3" stroke-dasharray="8,4"
        marker-end="url(#arrowhead)" />
  <circle id="origin-dot" cx="0" cy="0" r="6" fill="#34C759" />
</svg>

<div id="distance-label">0.00 m</div>

<div id="confirm-dialog">
  <h3>¬øQu√© deseas hacer?</h3>
  <div class="buttons">
    <button class="btn-continue" onclick="continueMoving()">Continuar Moviendo</button>
    <button class="btn-finish" onclick="finishMoving()">Terminar</button>
  </div>
</div>

<div id="distance-input-dialog">
  <h3>Distancia de Desplazamiento</h3>
  <input type="number" id="distance-input" step="0.1" value="0.00" />
  <button class="btn-apply" onclick="applyDistance()">Aplicar</button>
  <button class="btn-cancel" onclick="closeDistanceDialog()">Cancelar</button>
</div>

<div id="toolbar-container">
  <div id="toolbar">
    <button class="tool-btn" onclick="spawn('box')">üì¶<span class="label">Cubo</span></button>
    <button class="tool-btn" onclick="spawn('sphere')">‚ö™<span class="label">Esfera</span></button>
    <div class="divider"></div>
    <button class="tool-btn active" id="btn-move" onclick="setMode('translate')">‚ÜîÔ∏è<span class="label">Mover</span></button>
    <button class="tool-btn" id="btn-rot" onclick="setMode('rotate')">üîÑ<span class="label">Rotar</span></button>
    <button class="tool-btn" id="btn-scale" onclick="setMode('scale')">üîç<span class="label">Escala</span></button>
    <div class="divider"></div>
    <button class="tool-btn btn-delete" onclick="del()">üóëÔ∏è<span class="label">Borrar</span></button>
    <button class="tool-btn" onclick="randomColor()">üé®<span class="label">Color</span></button>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// === CONFIGURACI√ìN ===
const CFG = {
  bg: 0xf2f2f7,
  objColor: 0xdbe4eb,
  objEdge: 0xffffff,
  selColor: 0xFF9500,
  selColorLight: 0xFFB84D,
  maxDistance: 20.0,
  minScale: 0.05,
  arrowSize: 2.5,          // Tama√±o de flechas
  movementSpeed: 0.08,
  zoomSensitivity: 0.15,
  minZoom: 3,
  maxZoom: 30
};

let scene, camera, renderer, orbit;
const objects = [];
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let currentRenderMode = 'flat';
let gridTexture = null;

// Sistema de Flechas 3D
let arrowHelpers = null;
let selectedObject = null;
let activeArrow = null;

// Touch Logic
let lastTapTime = 0;
let touchStartX = 0, touchStartY = 0;
let isDragging = false;
let dragStartPos = new THREE.Vector2();

// Sistema de Medici√≥n
let originPosition = new THREE.Vector3();
let currentDistance = 0;
const measurementLine = document.getElementById('measurement-line');
const distanceLabel = document.getElementById('distance-label');
const confirmDialog = document.getElementById('confirm-dialog');
const distanceInputDialog = document.getElementById('distance-input-dialog');

// Zoom Inteligente
let initialCameraDistance = 0;
let maxDragDistance = 0;

// Estado de manipulaci√≥n
let isManipulating = false;
let manipulationTimer = null;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(CFG.bg);
  scene.fog = new THREE.Fog(CFG.bg, 20, 60);

  // C√°mara
  camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(5, 6, 8);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // Luces
  scene.add(new THREE.HemisphereLight(0xffffff, 0xffffff, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 1.5);
  dir.position.set(5, 15, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048, 2048);
  scene.add(dir);

  // Grid
  const grid = new THREE.GridHelper(60, 60, 0xc7c7cc, 0xe5e5ea);
  scene.add(grid);
  
  // Ejes globales
  const globalAxes = new THREE.AxesHelper(2.5);
  globalAxes.material.depthTest = false; 
  globalAxes.renderOrder = 1;
  scene.add(globalAxes);

  gridTexture = createTechTexture();

  // Orbit Controls
  orbit = new OrbitControls(camera, renderer.domElement);
  orbit.enableDamping = true;
  orbit.dampingFactor = 0.05;
  orbit.maxPolarAngle = Math.PI / 2 - 0.05;
  orbit.minDistance = CFG.minZoom;
  orbit.maxDistance = CFG.maxZoom;

  window.addEventListener('resize', onResize);
  setupTouchEvents();
  setupDistanceInput();

  // UI
  document.getElementById('btn-start').addEventListener('click', () => {
    document.getElementById('overlay').style.opacity = 0;
    setTimeout(() => {
      document.getElementById('overlay').style.display = 'none';
    }, 500);
    spawn('box');
  });

  // Funciones Globales
  window.spawn = spawn;
  window.setMode = setMode;
  window.del = del;
  window.setRenderMode = setRenderMode;
  window.randomColor = randomColor;
  window.applyDistance = applyDistance;
  window.closeDistanceDialog = closeDistanceDialog;
  window.continueMoving = continueMoving;
  window.finishMoving = finishMoving;
}

// === CREAR FLECHAS 3D ===
function createArrowHelpers(targetObject) {
  if (arrowHelpers) {
    scene.remove(arrowHelpers);
  }

  arrowHelpers = new THREE.Group();
  arrowHelpers.name = 'ArrowHelpers';

  const arrowLength = CFG.arrowSize;
  const arrowHeadLength = 0.6;
  const arrowHeadWidth = 0.4;

  // Flecha X (Roja)
  const arrowX = new THREE.ArrowHelper(
    new THREE.Vector3(1, 0, 0),
    new THREE.Vector3(0, 0, 0),
    arrowLength,
    0xFF3B30,
    arrowHeadLength,
    arrowHeadWidth
  );
  arrowX.name = 'ArrowX';
  arrowX.userData.axis = 'x';
  arrowX.line.material.linewidth = 5;
  
  // Flecha Y (Verde)
  const arrowY = new THREE.ArrowHelper(
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, 0, 0),
    arrowLength,
    0x34C759,
    arrowHeadLength,
    arrowHeadWidth
  );
  arrowY.name = 'ArrowY';
  arrowY.userData.axis = 'y';
  arrowY.line.material.linewidth = 5;
  
  // Flecha Z (Azul)
  const arrowZ = new THREE.ArrowHelper(
    new THREE.Vector3(0, 0, 1),
    new THREE.Vector3(0, 0, 0),
    arrowLength,
    0x007AFF,
    arrowHeadLength,
    arrowHeadWidth
  );
  arrowZ.name = 'ArrowZ';
  arrowZ.userData.axis = 'z';
  arrowZ.line.material.linewidth = 5;

  // Centro para movimiento libre (esfera blanca)
  const centerGeo = new THREE.SphereGeometry(0.3, 16, 16);
  const centerMat = new THREE.MeshBasicMaterial({ 
    color: 0xFFFFFF, 
    transparent: true, 
    opacity: 0.8,
    depthTest: false
  });
  const centerSphere = new THREE.Mesh(centerGeo, centerMat);
  centerSphere.name = 'CenterSphere';
  centerSphere.userData.axis = 'free';
  centerSphere.renderOrder = 999;

  arrowHelpers.add(arrowX);
  arrowHelpers.add(arrowY);
  arrowHelpers.add(arrowZ);
  arrowHelpers.add(centerSphere);

  // Hacer todos los elementos siempre visibles (X-Ray)
  arrowHelpers.traverse((child) => {
    if (child.material) {
      child.material.depthTest = false;
      child.material.depthWrite = false;
      child.renderOrder = 999;
    }
  });

  arrowHelpers.position.copy(targetObject.position);
  scene.add(arrowHelpers);
  
  return arrowHelpers;
}

function hideArrows() {
  if (arrowHelpers) {
    arrowHelpers.visible = false;
  }
}

function showArrows() {
  if (arrowHelpers) {
    arrowHelpers.visible = true;
  }
}

function removeArrows() {
  if (arrowHelpers) {
    scene.remove(arrowHelpers);
    arrowHelpers = null;
  }
}

// === L√ìGICA T√ÅCTIL ===
function setupTouchEvents() {
  const canvas = renderer.domElement;

  canvas.addEventListener('pointerdown', (e) => {
    touchStartX = e.clientX; 
    touchStartY = e.clientY;
    dragStartPos.set(e.clientX, e.clientY);
    
    // Verificar si toc√≥ una flecha
    if (selectedObject && arrowHelpers) {
      const arrow = getIntersectedArrow(e.clientX, e.clientY);
      if (arrow) {
        activeArrow = arrow;
        isDragging = true;
        isManipulating = true;
        orbit.enabled = false; // BLOQUEAR C√ÅMARA
        originPosition.copy(selectedObject.position);
        initialCameraDistance = camera.position.length();
        maxDragDistance = 0;
        hideArrows(); // OCULTAR FLECHAS AL ARRASTRAR
        showMeasurementLine();
      }
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (isDragging && selectedObject && activeArrow) {
      moveObjectWithArrow(e.clientX, e.clientY);
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    const dist = Math.hypot(e.clientX - touchStartX, e.clientY - touchStartY);

    if (isDragging) {
      // Termin√≥ de arrastrar
      isDragging = false;
      activeArrow = null;
      hideMeasurementLine();
      showArrows(); // MOSTRAR FLECHAS AL SOLTAR
      
      // Mostrar pop-up despu√©s de un momento
      clearTimeout(manipulationTimer);
      manipulationTimer = setTimeout(() => {
        showConfirmDialog();
      }, 300);
      
    } else if (dist < 15) {
      // Es un tap
      const now = Date.now();
      if (now - lastTapTime < 400) {
        handleDoubleTap(e.clientX, e.clientY);
        showTapEffect(e.clientX, e.clientY);
        lastTapTime = 0;
      } else {
        lastTapTime = now;
      }
    }
  });
}

function getIntersectedArrow(x, y) {
  if (!arrowHelpers) return null;

  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((y - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  
  const arrowObjects = [];
  arrowHelpers.traverse((child) => {
    if (child.isMesh || child.isLine) {
      arrowObjects.push(child);
    }
  });
  
  const intersects = raycaster.intersectObjects(arrowObjects, true);
  
  if (intersects.length > 0) {
    let obj = intersects[0].object;
    while (obj.parent && obj.parent !== arrowHelpers) {
      obj = obj.parent;
    }
    return obj;
  }
  
  return null;
}

function moveObjectWithArrow(x, y) {
  if (!selectedObject || !activeArrow) return;

  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((y - rect.top) / rect.height) * 2 + 1;

  const axis = activeArrow.userData.axis;
  const movementScale = 0.05;

  if (axis === 'x') {
    selectedObject.position.x += (x - dragStartPos.x) * movementScale;
  } else if (axis === 'y') {
    selectedObject.position.y -= (y - dragStartPos.y) * movementScale;
  } else if (axis === 'z') {
    selectedObject.position.z += (y - dragStartPos.y) * movementScale;
  } else if (axis === 'free') {
    // Movimiento libre en plano XZ
    const deltaX = (x - dragStartPos.x) * movementScale;
    const deltaZ = (y - dragStartPos.y) * movementScale;
    selectedObject.position.x += deltaX;
    selectedObject.position.z += deltaZ;
  }

  dragStartPos.set(x, y);
  
  enforceLimits(selectedObject);
  updateArrowPosition();
  updateMeasurementLine();
  updateIntelligentZoom();
}

function updateArrowPosition() {
  if (arrowHelpers && selectedObject) {
    arrowHelpers.position.copy(selectedObject.position);
  }
}

function handleDoubleTap(x, y) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((y - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(objects, false);

  if (intersects.length > 0) {
    const hit = intersects[0].object;
    if (selectedObject === hit) {
      deselectObject();
    } else {
      selectObject(hit);
    }
  } else {
    deselectObject();
  }
}

function selectObject(obj) {
  // Deseleccionar anterior
  if (selectedObject) {
    deselectObject();
  }
  
  selectedObject = obj;
  isManipulating = true;
  
  // OBJETO NARANJA COMPLETO
  obj.material.color.setHex(CFG.selColor);
  if (obj.userData.edges) {
    obj.userData.edges.material.color.setHex(CFG.selColorLight);
    obj.userData.edges.material.opacity = 0.8;
  }
  
  // CREAR FLECHAS
  createArrowHelpers(obj);
  
  // BLOQUEAR √ìRBITA
  orbit.enabled = false;
  
  originPosition.copy(obj.position);
  initialCameraDistance = camera.position.length();
}

function deselectObject() {
  if (selectedObject) {
    // Restaurar color original
    selectedObject.material.color.setHex(CFG.objColor);
    if (selectedObject.userData.edges) {
      selectedObject.userData.edges.material.color.setHex(CFG.objEdge);
      selectedObject.userData.edges.material.opacity = 0.5;
    }
    
    selectedObject = null;
  }
  
  removeArrows();
  hideMeasurementLine();
  hideConfirmDialog();
  isManipulating = false;
  
  // REACTIVAR √ìRBITA
  orbit.enabled = true;
}

// === POP-UP DE CONFIRMACI√ìN ===
function showConfirmDialog() {
  confirmDialog.classList.add('visible');
}

function hideConfirmDialog() {
  confirmDialog.classList.remove('visible');
}

function continueMoving() {
  hideConfirmDialog();
  if (selectedObject) {
    originPosition.copy(selectedObject.position);
    showArrows();
  }
}

function finishMoving() {
  hideConfirmDialog();
  deselectObject();
}

// === ZOOM INTELIGENTE ===
function updateIntelligentZoom() {
  if (!selectedObject || !isDragging) return;
  
  const objPos = selectedObject.position;
  const distance = objPos.distanceTo(originPosition);
  
  maxDragDistance = Math.max(maxDragDistance, distance);
  
  let targetZoom;
  
  if (distance > maxDragDistance * 0.5) {
    targetZoom = initialCameraDistance + (distance * 2);
  } else {
    const returnRatio = distance / maxDragDistance;
    targetZoom = THREE.MathUtils.lerp(
      initialCameraDistance,
      initialCameraDistance + (maxDragDistance * 2),
      returnRatio
    );
  }
  
  targetZoom = THREE.MathUtils.clamp(targetZoom, CFG.minZoom, CFG.maxZoom);
  
  const currentZoom = camera.position.length();
  const newZoom = THREE.MathUtils.lerp(currentZoom, targetZoom, CFG.zoomSensitivity);
  
  const direction = camera.position.clone().normalize();
  camera.position.copy(direction.multiplyScalar(newZoom));
  orbit.target.copy(objPos);
  camera.lookAt(objPos);
}

// === SISTEMA DE MEDICI√ìN ===
function showMeasurementLine() {
  measurementLine.classList.add('visible');
  distanceLabel.classList.add('visible');
}

function hideMeasurementLine() {
  measurementLine.classList.remove('visible');
  distanceLabel.classList.remove('visible');
}

function updateMeasurementLine() {
  if (!selectedObject || !measurementLine.classList.contains('visible')) return;
  
  const objPos = selectedObject.position;
  currentDistance = objPos.distanceTo(originPosition);
  
  const origin2D = toScreenPosition(originPosition);
  const current2D = toScreenPosition(objPos);
  
  const line = document.getElementById('measure-line');
  const originDot = document.getElementById('origin-dot');
  
  line.setAttribute('x1', origin2D.x);
  line.setAttribute('y1', origin2D.y);
  line.setAttribute('x2', current2D.x);
  line.setAttribute('y2', current2D.y);
  
  originDot.setAttribute('cx', origin2D.x);
  originDot.setAttribute('cy', origin2D.y);
  
  distanceLabel.textContent = currentDistance.toFixed(2) + ' m';
  
  const midX = (origin2D.x + current2D.x) / 2;
  const midY = (origin2D.y + current2D.y) / 2;
  
  distanceLabel.style.left = midX + 'px';
  distanceLabel.style.top = (midY - 30) + 'px';
}

function toScreenPosition(position) {
  const vector = position.clone();
  vector.project(camera);
  
  return {
    x: (vector.x * 0.5 + 0.5) * window.innerWidth,
    y: (-(vector.y * 0.5) + 0.5) * window.innerHeight
  };
}

// === INPUT DE DISTANCIA ===
function setupDistanceInput() {
  distanceLabel.addEventListener('click', () => {
    if (!selectedObject) return;
    
    document.getElementById('distance-input').value = currentDistance.toFixed(2);
    distanceInputDialog.classList.add('visible');
    document.getElementById('distance-input').focus();
  });
  
  document.getElementById('distance-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') applyDistance();
  });
}

function applyDistance() {
  const input = document.getElementById('distance-input');
  const newDistance = parseFloat(input.value);
  
  if (!selectedObject || isNaN(newDistance)) return;
  
  const direction = selectedObject.position.clone().sub(originPosition).normalize();
  const newPos = originPosition.clone().add(direction.multiplyScalar(newDistance));
  selectedObject.position.copy(newPos);
  
  enforceLimits(selectedObject);
  updateArrowPosition();
  updateMeasurementLine();
  closeDistanceDialog();
}

function closeDistanceDialog() {
  distanceInputDialog.classList.remove('visible');
}

// === L√çMITES ===
function enforceLimits(obj) {
  if (!obj) return;

  if (obj.position.length() > CFG.maxDistance) {
    obj.position.setLength(CFG.maxDistance);
  }

  if (obj.position.y < 0) obj.position.y = 0;

  obj.scale.x = Math.max(obj.scale.x, CFG.minScale);
  obj.scale.y = Math.max(obj.scale.y, CFG.minScale);
  obj.scale.z = Math.max(obj.scale.z, CFG.minScale);
}

// === CREACI√ìN ===
function spawn(type) {
  let geo;
  if(type === 'box') geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
  else geo = new THREE.SphereGeometry(0.9, 48, 48);

  const mat = new THREE.MeshStandardMaterial({
    color: CFG.objColor, roughness: 0.4, metalness: 0.1
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = true; 
  mesh.receiveShadow = true;
  mesh.position.set((Math.random()-0.5)*2, 0.75, (Math.random()-0.5)*2);

  const edges = new THREE.LineSegments(
    new THREE.EdgesGeometry(geo),
    new THREE.LineBasicMaterial({ color: CFG.objEdge, transparent:true, opacity:0.5 })
  );
  mesh.add(edges);
  mesh.userData.edges = edges;
  mesh.userData.originalColor = CFG.objColor;

  scene.add(mesh);
  objects.push(mesh);
  applyRenderMode(mesh, currentRenderMode);
}

// === MODOS ===
function setMode(mode) {
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
  const map = {translate:'btn-move', rotate:'btn-rot', scale:'btn-scale'};
  const id = map[mode];
  if(id) document.getElementById(id).classList.add('active');
}

function setRenderMode(mode, btn) {
  currentRenderMode = mode;
  document.querySelectorAll('.render-opt').forEach(b => b.classList.remove('active'));
  if(btn) btn.classList.add('active');
  objects.forEach(o => applyRenderMode(o, mode));
}

function applyRenderMode(mesh, mode) {
  const m = mesh.material;
  const e = mesh.userData.edges;
  if (mode === 'flat') {
    m.map = null; m.roughness = 0.4; 
    if(mesh !== selectedObject) m.color.setHex(CFG.objColor);
    if(e) e.visible = true;
  } else if (mode === 'lightmap') {
    m.map = null; m.roughness = 1; 
    if(mesh !== selectedObject) m.color.setHex(0xd0d0d5);
    if(e) e.visible = false;
  } else if (mode === 'workbench') {
    m.map = gridTexture; m.roughness = 0.5; 
    if(mesh !== selectedObject) m.color.setHex(0xffffff);
    if(e) e.visible = true;
  }
  m.needsUpdate = true;
}

function del() {
  if(selectedObject) {
    const o = selectedObject;
    deselectObject();
    scene.remove(o);
    const idx = objects.indexOf(o);
    if(idx >= 0) objects.splice(idx, 1);
  }
}

function randomColor() {
  if(selectedObject) {
    const newColor = Math.random()*0xffffff;
    selectedObject.material.color.setHex(newColor);
    selectedObject.userData.originalColor = newColor;
  }
}

// === UTILS ===
function showTapEffect(x, y) {
  const el = document.createElement('div');
  el.className = 'tap-indicator';
  el.style.left = x + 'px'; 
  el.style.top = y + 'px';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 500);
}

function createTechTexture() {
  const c = document.createElement('canvas'); 
  c.width = 512; c.height = 512;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#f0f0f5'; 
  ctx.fillRect(0,0,512,512);
  ctx.strokeStyle = '#d1d1d6'; 
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i=0; i<=512; i+=64) {
    ctx.moveTo(i,0); ctx.lineTo(i,512);
    ctx.moveTo(0,i); ctx.lineTo(512,i);
  }
  ctx.stroke();
  const t = new THREE.CanvasTexture(c);
  t.wrapS = t.wrapT = THREE.RepeatWrapping;
  return t;
}

function onResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  
  if (!isManipulating) {
    orbit.update();
  }
  
  renderer.render(scene, camera);
}
</script>
</body>
</html>
