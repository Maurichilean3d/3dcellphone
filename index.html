<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover" />
  <title>MR Studio Mobile (3-Part)</title>

  <style>
    :root{
      --bg-primary:#f2f2f7; --bg-secondary:#ffffff;
      --text-primary:#1c1c1e; --text-secondary:#8e8e93;
      --shadow:rgba(0,0,0,.15);
    }
    body.dark-mode{
      --bg-primary:#1c1c1e; --bg-secondary:#2c2c2e;
      --text-primary:#ffffff; --text-secondary:#98989d;
      --shadow:rgba(0,0,0,.5);
    }
    body{
      margin:0; background:var(--bg-primary); overflow:hidden;
      font-family:-apple-system,"SF Pro Text",sans-serif;
      -webkit-user-select:none; user-select:none; touch-action:none;
      color:var(--text-primary);
    }

    #overlay{
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      background:rgba(255,255,255,.95); backdrop-filter:blur(25px);
      z-index:999;
      transition:opacity .35s ease;
    }
    body.dark-mode #overlay{ background:rgba(28,28,30,.95); }
    h1{ margin:0 0 10px 0; font-size:30px; font-weight:900; letter-spacing:-1px; }
    p{ margin:0 0 26px 0; color:var(--text-secondary); font-weight:700; text-align:center; max-width:86%; }

    #theme-selector{ display:flex; gap:12px; margin-bottom:28px; }
    .theme-option{
      padding:12px 18px; border-radius:16px;
      border:2px solid #e5e5ea; background:#fff;
      font-weight:900; cursor:pointer; display:flex; gap:8px; align-items:center;
      transition:.2s;
    }
    .theme-option.active{ background:#FF9500; border-color:#FF9500; color:#fff; }
    .theme-option:active{ transform:scale(.97); }

    button.start-btn{
      padding:16px 46px; border:none; border-radius:40px;
      background:#FF9500; color:#fff; font-size:18px; font-weight:900;
      box-shadow:0 10px 26px rgba(255,149,0,.35);
      cursor:pointer; transition:.2s;
    }
    button.start-btn:active{ transform:scale(.97); }

    /* top bars */
    #render-bar, #camera-bar{
      position:absolute; left:50%; transform:translateX(-50%);
      display:flex; gap:6px;
      padding:4px; border-radius:14px;
      background:rgba(255,255,255,.9); backdrop-filter:blur(18px);
      box-shadow:0 6px 18px rgba(0,0,0,.08);
      z-index:120; max-width:92%;
      overflow-x:auto; -webkit-overflow-scrolling:touch;
      scrollbar-width:none;
    }
    #render-bar{ top:calc(50px + env(safe-area-inset-top)); }
    #camera-bar{ top:calc(108px + env(safe-area-inset-top)); }
    #render-bar::-webkit-scrollbar, #camera-bar::-webkit-scrollbar{ display:none; }

    .render-opt, .cam-opt{
      border:none; background:transparent;
      padding:8px 14px; border-radius:10px;
      font-size:12px; font-weight:900; color:#999; cursor:pointer;
      white-space:nowrap; transition:.2s;
    }
    .render-opt.active, .cam-opt.active{
      background:#fff; color:#000; box-shadow:0 3px 10px rgba(0,0,0,.12);
    }
    .icon-btn{
      width:44px; height:36px; border-radius:10px; border:none;
      background:rgba(235,235,240,.6);
      font-size:18px; font-weight:900; cursor:pointer;
      transition:.2s;
    }
    body.dark-mode .icon-btn{ background:rgba(255,255,255,.12); color:#fff; }
    .icon-btn:active{ transform:scale(.97); }
    .icon-btn[disabled]{ opacity:.35; cursor:default; transform:none; }

    /* floating buttons */
    #exit-manipulation{
      position:absolute;
      top:calc(50px + env(safe-area-inset-top));
      right:calc(18px + env(safe-area-inset-right));
      width:44px; height:44px; border-radius:22px;
      background:rgba(255,59,48,.95);
      color:#fff; border:none; font-size:22px; font-weight:900;
      display:none; align-items:center; justify-content:center;
      box-shadow:0 10px 26px rgba(255,59,48,.35);
      z-index:160; cursor:pointer;
    }
    #exit-manipulation.visible{ display:flex; }
    #exit-manipulation:active{ transform:scale(.92); }

    #space-toggle{
      position:absolute;
      top:calc(168px + env(safe-area-inset-top));
      left:50%; transform:translateX(-50%);
      padding:10px 16px;
      border-radius:20px;
      background:rgba(255,255,255,.92);
      border:2px solid #FF9500;
      font-size:13px; font-weight:900;
      display:none; align-items:center; gap:7px;
      box-shadow:0 10px 26px rgba(255,149,0,.22);
      z-index:160; cursor:pointer;
    }
    #space-toggle.visible{ display:flex; }
    #space-toggle.local{
      background:rgba(52,199,89,.95);
      border-color:#34C759;
      color:#fff;
    }

    #edit-values-btn{
      position:absolute;
      width:56px; height:56px;
      background:rgba(255,149,0,.95);
      border:3px solid #fff;
      border-radius:28px;
      color:#fff; font-size:26px; font-weight:900;
      box-shadow:0 14px 34px rgba(255,149,0,.4);
      display:none; align-items:center; justify-content:center;
      z-index:200; cursor:pointer;
    }
    #edit-values-btn.visible{ display:flex; }
    #edit-values-btn:active{ transform:scale(.92); }

    /* bottom toolbar */
    #toolbar-container{
      position:absolute;
      bottom:calc(35px + env(safe-area-inset-bottom));
      left:0; right:0;
      display:flex; justify-content:center;
      pointer-events:none; z-index:140;
    }
    #toolbar{
      pointer-events:auto;
      display:flex; gap:12px; padding:12px 16px;
      background:rgba(255,255,255,.9); backdrop-filter:blur(26px);
      border-radius:28px;
      box-shadow:0 18px 46px rgba(0,0,0,.16);
      max-width:94%;
      overflow-x:auto; -webkit-overflow-scrolling:touch;
      scrollbar-width:none;
      border:1px solid rgba(255,255,255,.45);
    }
    #toolbar::-webkit-scrollbar{ display:none; }
    .tool-btn{
      width:56px; height:56px; border-radius:18px; border:none;
      background:rgba(235,235,240,.62);
      font-size:26px; font-weight:900;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      cursor:pointer; transition:.2s; color:#1c1c1e; flex-shrink:0;
    }
    body.dark-mode .tool-btn{ background:rgba(255,255,255,.12); color:#fff; }
    .tool-btn.active{ background:#FF9500; color:#fff; box-shadow:0 10px 22px rgba(255,149,0,.24); }
    .tool-btn:active{ transform:scale(.97); }
    .label{ font-size:9px; margin-top:3px; font-weight:900; opacity:.7; }
    .divider{ width:1px; background:rgba(0,0,0,.12); margin:0 4px; }

    /* subtoolbar (thin carousel) */
    #subtoolbar-container{
      position:absolute;
      bottom:calc(112px + env(safe-area-inset-bottom));
      left:0; right:0;
      display:flex; justify-content:center;
      pointer-events:none; z-index:150;
    }
    #subtoolbar{
      pointer-events:auto;
      display:none; gap:10px; padding:8px 12px;
      background:rgba(255,255,255,.86); backdrop-filter:blur(22px);
      border-radius:22px;
      box-shadow:0 14px 34px rgba(0,0,0,.14);
      max-width:92%;
      overflow-x:auto; -webkit-overflow-scrolling:touch;
      scrollbar-width:none;
      border:1px solid rgba(255,255,255,.35);
    }
    body.dark-mode #subtoolbar{ background:rgba(44,44,46,.86); border-color:rgba(255,255,255,.12); }
    #subtoolbar.visible{ display:flex; }
    #subtoolbar::-webkit-scrollbar{ display:none; }

    .sub-btn{
      height:38px; padding:0 14px; border-radius:14px; border:none;
      background:rgba(235,235,240,.62);
      font-weight:900; font-size:12px;
      cursor:pointer; display:flex; align-items:center; gap:8px;
      transition:.2s; flex-shrink:0;
    }
    body.dark-mode .sub-btn{ background:rgba(255,255,255,.12); color:#fff; }
    .sub-btn.active{
      background:rgba(52,199,89,.95);
      color:#fff;
      box-shadow:0 12px 26px rgba(52,199,89,.22);
    }
    .pill{
      width:18px; height:18px; border-radius:6px;
      background:rgba(0,0,0,.08);
      display:inline-flex; align-items:center; justify-content:center;
      font-size:12px; font-weight:900;
    }

    /* measurement */
    #measurement-line{ position:absolute; pointer-events:none; opacity:0; transition:opacity .15s; z-index:155; }
    #measurement-line.visible{ opacity:1; }
    #distance-label{
      position:absolute;
      background:rgba(0,0,0,.9); color:#fff;
      padding:8px 14px; border-radius:16px;
      font-family:'SF Mono','Monaco',monospace;
      font-weight:900; font-size:14px;
      opacity:0; transition:opacity .15s;
      z-index:170; pointer-events:none;
    }
    #distance-label.visible{ opacity:1; }

    /* confirm mini */
    #confirm-dialog{
      position:absolute;
      bottom:calc(150px + env(safe-area-inset-bottom));
      left:50%; transform:translateX(-50%);
      display:none; gap:12px; align-items:center;
      padding:10px; border-radius:22px;
      background:rgba(255,255,255,.96); backdrop-filter:blur(20px);
      box-shadow:0 20px 60px rgba(0,0,0,.24);
      z-index:210;
    }
    body.dark-mode #confirm-dialog{ background:rgba(44,44,46,.96); }
    #confirm-dialog.visible{ display:flex; }
    .mini-btn{
      width:56px; height:56px; border-radius:18px; border:none;
      font-size:26px; font-weight:900;
      color:#fff; cursor:pointer; transition:.15s;
    }
    .mini-btn:active{ transform:scale(.95); }
    .mini-btn.cancel{ background:rgba(255,59,48,.95); }
    .mini-btn.ok{ background:rgba(52,199,89,.95); }

    /* axis dialog */
    #axis-input-dialog{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      display:none; z-index:260;
      min-width:340px;
      padding:26px; border-radius:24px;
      background:rgba(255,255,255,.98); backdrop-filter:blur(20px);
      box-shadow:0 22px 70px rgba(0,0,0,.3);
    }
    body.dark-mode #axis-input-dialog{ background:rgba(44,44,46,.98); color:#fff; }
    #axis-input-dialog.visible{ display:block; }
    #axis-input-dialog h3{ margin:0 0 8px 0; font-weight:900; font-size:20px; text-align:center; }
    #axis-input-dialog .axis-name{ margin:0 0 18px 0; text-align:center; color:var(--text-secondary); font-weight:800; font-size:13px; }
    .input-row{ display:flex; align-items:center; gap:12px; margin-bottom:12px; }
    .input-label{
      width:30px; height:30px; border-radius:8px;
      display:flex; align-items:center; justify-content:center;
      color:#fff; font-weight:900;
    }
    .input-label.x{ background:#FF3B30; }
    .input-label.y{ background:#34C759; }
    .input-label.z{ background:#007AFF; }
    .axis-input-field{
      flex:1;
      padding:16px; font-size:22px; font-weight:900; text-align:center;
      border-radius:12px; border:2px solid #e5e5ea;
      font-family:'SF Mono','Monaco',monospace;
      outline:none;
    }
    body.dark-mode .axis-input-field{ background:rgba(28,28,30,.6); border-color:rgba(255,255,255,.18); color:#fff; }
    .axis-input-field:focus{ border-color:#FF9500; }
    .buttons{ display:flex; gap:12px; margin-top:16px; }
    .btn-apply, .btn-cancel{
      flex:1; border:none; border-radius:14px;
      padding:14px; font-weight:900; font-size:16px; color:#fff;
      cursor:pointer;
    }
    .btn-apply{ background:#34C759; }
    .btn-cancel{ background:#FF3B30; }
    .btn-apply:active, .btn-cancel:active{ transform:scale(.97); }

    /* edit camera panel (right side) */
    #edit-cam-panel{
      position:absolute;
      right:calc(14px + env(safe-area-inset-right));
      top:50%;
      transform:translateY(-50%);
      display:none; flex-direction:column; gap:12px;
      z-index:220;
    }
    #edit-cam-panel.visible{ display:flex; }
    .camlock-btn{
      width:56px; height:56px; border-radius:18px;
      border:2px solid rgba(255,255,255,.6);
      background:rgba(255,255,255,.9);
      backdrop-filter:blur(16px);
      box-shadow:0 14px 32px rgba(0,0,0,.14);
      font-size:24px; font-weight:900;
      cursor:pointer; transition:.15s;
    }
    body.dark-mode .camlock-btn{ background:rgba(44,44,46,.9); border-color:rgba(255,255,255,.12); color:#fff; }
    .camlock-btn.active{
      background:rgba(0,122,255,.92);
      color:#fff;
      border-color:rgba(0,122,255,.35);
      box-shadow:0 14px 34px rgba(0,122,255,.22);
    }
    .camlock-btn:active{ transform:scale(.95); }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>

  <div id="overlay">
    <h1>MR STUDIO</h1>
    <p>Mobile CAD-like: objetos + v√©rtices/bordes/caras + undo/redo + c√°mara controlada</p>

    <div id="theme-selector">
      <div class="theme-option active" id="theme-light">‚òÄÔ∏è <span>Modo Claro</span></div>
      <div class="theme-option" id="theme-dark">üåô <span>Modo Oscuro</span></div>
    </div>

    <button class="start-btn" id="btn-start">Comenzar</button>
  </div>

  <div id="render-bar">
    <button class="render-opt active" data-render="flat">Plano</button>
    <button class="render-opt" data-render="clay">Clay</button>
    <button class="render-opt" data-render="tech">Tech</button>
  </div>

  <div id="camera-bar">
    <button class="icon-btn" id="btn-undo" title="Undo" disabled>‚ü≤</button>
    <button class="icon-btn" id="btn-redo" title="Redo" disabled>‚ü≥</button>

    <button class="cam-opt" data-cam="fitall">Fit All</button>
    <button class="cam-opt" data-cam="focus">Focus</button>
    <button class="cam-opt" data-cam="iso">Iso</button>
    <button class="cam-opt" data-cam="top">Top</button>
    <button class="cam-opt" data-cam="front">Front</button>
    <button class="cam-opt" data-cam="right">Right</button>
  </div>

  <button id="exit-manipulation">‚úï</button>

  <button id="space-toggle">
    <span id="space-icon">üåç</span>
    <span id="space-text">Global</span>
  </button>

  <button id="edit-values-btn">‚úèÔ∏è</button>

  <div id="edit-cam-panel">
    <button class="camlock-btn" id="btn-cam-zoom" title="Zoom">üîç</button>
    <button class="camlock-btn" id="btn-cam-orbit" title="√ìrbita">üåÄ</button>
  </div>

  <svg id="measurement-line" width="100%" height="100%" style="position:absolute; inset:0;">
    <defs>
      <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
        <polygon points="0 0, 10 5, 0 10" fill="#FF9500" />
      </marker>
    </defs>
    <line id="measure-line" x1="0" y1="0" x2="0" y2="0"
          stroke="#FF9500" stroke-width="3" stroke-dasharray="8,4"
          marker-end="url(#arrowhead)" />
    <circle id="origin-dot" cx="0" cy="0" r="6" fill="#34C759" />
  </svg>

  <div id="distance-label">0.00 m</div>

  <div id="confirm-dialog">
    <button class="mini-btn cancel" id="btn-cancel">‚úï</button>
    <button class="mini-btn ok" id="btn-ok">‚úì</button>
  </div>

  <div id="axis-input-dialog">
    <h3 id="axis-title">Posici√≥n Exacta</h3>
    <div class="axis-name" id="axis-subtitle">Ingresa X, Y, Z</div>

    <div class="input-row">
      <div class="input-label x">X</div>
      <input type="number" id="input-x" class="axis-input-field" step="0.1" value="0.00"/>
    </div>
    <div class="input-row">
      <div class="input-label y">Y</div>
      <input type="number" id="input-y" class="axis-input-field" step="0.1" value="0.00"/>
    </div>
    <div class="input-row">
      <div class="input-label z">Z</div>
      <input type="number" id="input-z" class="axis-input-field" step="0.1" value="0.00"/>
    </div>

    <div class="buttons">
      <button class="btn-apply" id="btn-apply">‚úì Aplicar</button>
      <button class="btn-cancel" id="btn-close">‚úï Cancelar</button>
    </div>
  </div>

  <div id="subtoolbar-container">
    <div id="subtoolbar">
      <button class="sub-btn" id="sub-multi"><span class="pill">‚äï</span>Multi</button>
      <button class="sub-btn" id="sub-all"><span class="pill">‚òÖ</span>Todos</button>
      <button class="sub-btn" id="sub-verts"><span class="pill">V</span>V√©rtices</button>
      <button class="sub-btn" id="sub-edges"><span class="pill">E</span>Bordes</button>
      <button class="sub-btn" id="sub-faces"><span class="pill">F</span>Caras</button>
    </div>
  </div>

  <div id="toolbar-container">
    <div id="toolbar">
      <button class="tool-btn" data-spawn="box">üì¶<span class="label">Cubo</span></button>
      <button class="tool-btn" data-spawn="sphere">‚ö™<span class="label">Esfera</span></button>
      <button class="tool-btn" data-spawn="cylinder">ü•´<span class="label">Cil</span></button>
      <button class="tool-btn" data-spawn="cone">üî∫<span class="label">Cono</span></button>
      <button class="tool-btn" data-spawn="torus">üç©<span class="label">Toro</span></button>
      <button class="tool-btn" data-spawn="plane">üü¶<span class="label">Plano</span></button>
      <div class="divider"></div>

      <button class="tool-btn active" id="btn-move" data-mode="translate">‚ÜîÔ∏è<span class="label">Mover</span></button>
      <button class="tool-btn" id="btn-rot" data-mode="rotate">üîÑ<span class="label">Rotar</span></button>
      <button class="tool-btn" id="btn-scale" data-mode="scale">üîç<span class="label">Escala</span></button>
      <button class="tool-btn" id="btn-select" data-mode="select">‚úÖ<span class="label">Selec</span></button>

      <div class="divider"></div>
      <button class="tool-btn" id="btn-delete">üóëÔ∏è<span class="label">Borrar</span></button>
      <button class="tool-btn" id="btn-color">üé≤<span class="label">Color</span></button>
    </div>
  </div>

  <script type="module" src="./editor-core.js"></script>
</body>
</html>
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { setupSubcomponents } from './editor-subcomponents.js';

/* =============================
   CONFIG
============================= */
const CFG = {
  bg: 0xf2f2f7,
  objColor: 0xdbe4eb,
  objEdge: 0xffffff,
  selColor: 0xFF9500,
  selEdge: 0xFFB84D,

  subColorA: 0x34C759,
  subColorB: 0x00BFFF,

  minScale: 0.05,
  maxScale: 10.0,
  minZoom: 2,
  maxZoom: 80,
  maxDistance: 40,

  arrowSize: 2.6
};

const IS_MOBILE =
  matchMedia('(pointer: coarse)').matches ||
  Math.min(window.innerWidth, window.innerHeight) < 700;

/* =============================
   DOM
============================= */
const overlay = document.getElementById('overlay');
const btnStart = document.getElementById('btn-start');

const themeLight = document.getElementById('theme-light');
const themeDark = document.getElementById('theme-dark');

const renderBar = document.getElementById('render-bar');
const cameraBar = document.getElementById('camera-bar');

const btnExit = document.getElementById('exit-manipulation');
const spaceToggle = document.getElementById('space-toggle');
const spaceIcon = document.getElementById('space-icon');
const spaceText = document.getElementById('space-text');
const editValuesBtn = document.getElementById('edit-values-btn');

const subtoolbar = document.getElementById('subtoolbar');
const btnSubMulti = document.getElementById('sub-multi');
const btnSubAll = document.getElementById('sub-all');
const btnSubVerts = document.getElementById('sub-verts');
const btnSubEdges = document.getElementById('sub-edges');
const btnSubFaces = document.getElementById('sub-faces');

const btnUndo = document.getElementById('btn-undo');
const btnRedo = document.getElementById('btn-redo');

const confirmDialog = document.getElementById('confirm-dialog');
const btnCancel = document.getElementById('btn-cancel');
const btnOk = document.getElementById('btn-ok');

const axisDialog = document.getElementById('axis-input-dialog');
const axisTitle = document.getElementById('axis-title');
const axisSubtitle = document.getElementById('axis-subtitle');
const inputX = document.getElementById('input-x');
const inputY = document.getElementById('input-y');
const inputZ = document.getElementById('input-z');
const btnApply = document.getElementById('btn-apply');
const btnClose = document.getElementById('btn-close');

const measurementLine = document.getElementById('measurement-line');
const distanceLabel = document.getElementById('distance-label');
const measureLine = document.getElementById('measure-line');
const originDot = document.getElementById('origin-dot');

const editCamPanel = document.getElementById('edit-cam-panel');
const btnCamZoom = document.getElementById('btn-cam-zoom');
const btnCamOrbit = document.getElementById('btn-cam-orbit');

const toolbar = document.getElementById('toolbar');
const btnDelete = document.getElementById('btn-delete');
const btnColor = document.getElementById('btn-color');

/* =============================
   THREE CORE
============================= */
let scene, camera, renderer, orbit;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

const objects = [];
let nextObjectId = 1;

let gridTexture = null;
let currentRenderMode = 'flat';

/* =============================
   EDIT/SELECT STATE
============================= */
let selectedObject = null;
let selectedObjects = [];
let multiSelectEnabled = false;
let allSelectEnabled = false;

let currentMode = 'translate'; // translate|rotate|scale|select
let currentSpace = 'world';    // world|local

let currentGizmo = null;
let activeHandle = null;

let isDragging = false;
let dragStart = new THREE.Vector2();
let touchStart = new THREE.Vector2();
let lastTapTime = 0;

let originPosition = new THREE.Vector3();
let currentDistance = 0;

/* =============================
   CAMERA LOCKS DURING EDIT
============================= */
let isEditMode = false;
let editZoomEnabled = false;
let editOrbitEnabled = false;

function setEditMode(on) {
  isEditMode = on;
  if (on) {
    editZoomEnabled = false;
    editOrbitEnabled = false;
    editCamPanel.classList.add('visible');
    btnCamZoom.classList.toggle('active', editZoomEnabled);
    btnCamOrbit.classList.toggle('active', editOrbitEnabled);
    applyCameraLocks();
  } else {
    editCamPanel.classList.remove('visible');
    orbit.enableZoom = true;
    orbit.enableRotate = true;
    orbit.enablePan = true;
  }
}
function applyCameraLocks() {
  if (!isEditMode) return;
  orbit.enableZoom = !!editZoomEnabled;
  orbit.enableRotate = !!editOrbitEnabled;
  orbit.enablePan = false;
}
btnCamZoom.addEventListener('click', () => {
  if (!isEditMode) return;
  editZoomEnabled = !editZoomEnabled;
  btnCamZoom.classList.toggle('active', editZoomEnabled);
  applyCameraLocks();
});
btnCamOrbit.addEventListener('click', () => {
  if (!isEditMode) return;
  editOrbitEnabled = !editOrbitEnabled;
  btnCamOrbit.classList.toggle('active', editOrbitEnabled);
  applyCameraLocks();
});

/* =============================
   UNDO / REDO (actions)
============================= */
const undoStack = [];
const redoStack = [];

function updateUndoRedoUI() {
  btnUndo.disabled = undoStack.length === 0;
  btnRedo.disabled = redoStack.length === 0;
}
function pushAction(action) {
  undoStack.push(action);
  redoStack.length = 0;
  updateUndoRedoUI();
}
btnUndo.addEventListener('click', undo);
btnRedo.addEventListener('click', redo);

function snapshotTransform(obj) {
  return {
    pos: obj.position.toArray(),
    quat: obj.quaternion.toArray(),
    scl: obj.scale.toArray()
  };
}
function applySnapshot(obj, snap) {
  obj.position.fromArray(snap.pos);
  obj.quaternion.fromArray(snap.quat);
  obj.scale.fromArray(snap.scl);
  obj.rotation.setFromQuaternion(obj.quaternion);
}
function findById(id) {
  return objects.find(o => o.userData?.id === id) || null;
}
function removeObjectFromScene(obj) {
  scene.remove(obj);
  const i = objects.indexOf(obj);
  if (i >= 0) objects.splice(i, 1);
}
function performForward(a) {
  if (a.type === 'add') {
    for (const item of a.items) {
      const obj = createPrimitive(item.prim.type, item.prim.id);
      applySnapshot(obj, item.state);
      scene.add(obj);
      objects.push(obj);
      applyRenderMode(obj, currentRenderMode);
    }
  } else if (a.type === 'delete') {
    for (const id of a.ids) {
      const obj = findById(id);
      if (obj) removeObjectFromScene(obj);
    }
    deselectAll();
  } else if (a.type === 'transform') {
    const obj = findById(a.id);
    if (obj) applySnapshot(obj, a.after);
  } else if (a.type === 'vertexEdit') {
    // forward/inverse handled in subcomponents module via exported hooks
    subAPI.applyVertexEditForward(a);
  }
}
function performInverse(a) {
  if (a.type === 'add') {
    for (const item of a.items) {
      const obj = findById(item.prim.id);
      if (obj) removeObjectFromScene(obj);
    }
    deselectAll();
  } else if (a.type === 'delete') {
    for (const item of a.items) {
      const obj = createPrimitive(item.prim.type, item.prim.id);
      applySnapshot(obj, item.state);
      scene.add(obj);
      objects.push(obj);
      applyRenderMode(obj, currentRenderMode);
    }
  } else if (a.type === 'transform') {
    const obj = findById(a.id);
    if (obj) applySnapshot(obj, a.before);
  } else if (a.type === 'vertexEdit') {
    subAPI.applyVertexEditInverse(a);
  }
}
function undo() {
  const a = undoStack.pop();
  if (!a) return;
  redoStack.push(a);
  performInverse(a);
  updateUndoRedoUI();
}
function redo() {
  const a = redoStack.pop();
  if (!a) return;
  undoStack.push(a);
  performForward(a);
  updateUndoRedoUI();
}

/* =============================
   VIEWPORT / ZOOM HELPERS
============================= */
function isWorldPointOffscreen(worldPoint, margin = 0.12) {
  const v = worldPoint.clone().project(camera);
  const m = margin * 2;
  return (v.x < -1 + m) || (v.x > 1 - m) || (v.y < -1 + m) || (v.y > 1 - m);
}

/* =============================
   DRAG PLANE (smooth translate)
============================= */
let dragState = null;
// { plane, startHit, axisDirW|null, objCenterW, baseCamDist, objRadius }

function getCameraDir() {
  const d = new THREE.Vector3();
  camera.getWorldDirection(d);
  return d.normalize();
}
function intersectPlane(screenX, screenY, plane) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((screenX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((screenY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const p = new THREE.Vector3();
  const ok = raycaster.ray.intersectPlane(plane, p);
  return ok ? p : null;
}
function makeAxisDragPlane(axisDirW, anchorPointW) {
  const camDir = getCameraDir();
  let n = new THREE.Vector3().crossVectors(axisDirW, camDir);
  if (n.lengthSq() < 1e-8) {
    n = new THREE.Vector3().crossVectors(axisDirW, new THREE.Vector3(0, 1, 0));
    if (n.lengthSq() < 1e-8) n = new THREE.Vector3().crossVectors(axisDirW, new THREE.Vector3(1, 0, 0));
  }
  const planeNormal = new THREE.Vector3().crossVectors(n, axisDirW).normalize();
  return new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, anchorPointW);
}
function axisToVec(a) {
  if (a === 'x') return new THREE.Vector3(1, 0, 0);
  if (a === 'y') return new THREE.Vector3(0, 1, 0);
  if (a === 'z') return new THREE.Vector3(0, 0, 1);
  return new THREE.Vector3(1, 0, 0);
}
function beginTranslateDrag(axis, anchorW, objCenterW, objRadius) {
  let plane;
  let axisDirW = null;

  if (axis === 'free') {
    plane = new THREE.Plane().setFromNormalAndCoplanarPoint(getCameraDir(), anchorW);
  } else {
    axisDirW = axisToVec(axis);
    if (currentSpace === 'local' && selectedObject) axisDirW.applyQuaternion(selectedObject.quaternion).normalize();
    plane = makeAxisDragPlane(axisDirW, anchorW);
  }

  const startHit = intersectPlane(dragStart.x, dragStart.y, plane) || anchorW.clone();

  dragState = {
    plane,
    startHit,
    axisDirW,
    objCenterW: objCenterW.clone(),
    baseCamDist: camera.position.distanceTo(objCenterW),
    objRadius
  };
}

/* ‚úÖ Zoom inteligente: MUY leve, SOLO si se sale del encuadre */
function updateIntelligentZoomFromMoved(movedDistance) {
  if (!dragState) return;
  if (!isWorldPointOffscreen(dragState.objCenterW, 0.10)) return;

  const sizeFactor = Math.max(1, dragState.objRadius * 1.4);
  const target = dragState.baseCamDist + (movedDistance * 0.85) + (movedDistance / (sizeFactor * 2.0));
  const clamped = THREE.MathUtils.clamp(target, CFG.minZoom, CFG.maxZoom);

  const current = camera.position.distanceTo(dragState.objCenterW);
  const newDist = THREE.MathUtils.lerp(current, clamped, 0.10);

  const dir = camera.position.clone().sub(dragState.objCenterW).normalize();
  camera.position.copy(dragState.objCenterW.clone().add(dir.multiplyScalar(newDist)));
  orbit.target.copy(dragState.objCenterW);
  camera.lookAt(dragState.objCenterW);
  orbit.update();
}

/* =============================
   CAMERA PRESETS
============================= */
function fitBox(box) {
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const maxSize = Math.max(size.x, size.y, size.z);
  const fov = THREE.MathUtils.degToRad(camera.fov);
  const fitDist = (maxSize * 0.5) / Math.tan(fov * 0.5);
  const dist = THREE.MathUtils.clamp(fitDist * 2.4, CFG.minZoom, CFG.maxZoom);
  const dir = new THREE.Vector3(1, 0.85, 1).normalize();
  orbit.target.copy(center);
  camera.position.copy(center.clone().add(dir.multiplyScalar(dist)));
  camera.lookAt(center);
  orbit.update();
}
function fitAll() {
  if (!objects.length) return;
  const box = new THREE.Box3();
  objects.forEach(o => box.expandByObject(o));
  fitBox(box);
}
function focusSelected() {
  if (!selectedObject) return;
  const box = new THREE.Box3().setFromObject(selectedObject);
  fitBox(box);
}
function snapView(name) {
  const t = selectedObject
    ? new THREE.Box3().setFromObject(selectedObject).getCenter(new THREE.Vector3())
    : orbit.target.clone();

  const dist = THREE.MathUtils.clamp(camera.position.distanceTo(orbit.target), CFG.minZoom, CFG.maxZoom);
  let dir = new THREE.Vector3(1, 1, 1).normalize();
  if (name === 'iso') dir = new THREE.Vector3(1, 1, 1).normalize();
  if (name === 'top') dir = new THREE.Vector3(0, 1, 0);
  if (name === 'front') dir = new THREE.Vector3(0, 0, 1);
  if (name === 'right') dir = new THREE.Vector3(1, 0, 0);

  orbit.target.copy(t);
  camera.position.copy(t.clone().add(dir.multiplyScalar(dist)));
  camera.lookAt(t);
  orbit.update();
}

/* ‚úÖ Auto-focus al seleccionar: en m√≥vil NO hace zoom (solo recenter si se sali√≥) */
function focusSelectedSoft() {
  if (!selectedObject) return;

  const box = new THREE.Box3().setFromObject(selectedObject);
  const center = box.getCenter(new THREE.Vector3());

  if (!isWorldPointOffscreen(center, 0.10)) return;

  // recenter suave
  orbit.target.lerp(center, 0.22);

  // en m√≥vil: sin zoom por selecci√≥n
  if (IS_MOBILE) {
    orbit.update();
    return;
  }

  // en desktop: zoom leve solo si muy descalibrado
  const size = box.getSize(new THREE.Vector3());
  const maxSize = Math.max(size.x, size.y, size.z);
  const currentDist = camera.position.distanceTo(orbit.target);
  const desiredMin = Math.max(CFG.minZoom, maxSize * 1.8);
  const desiredMax = Math.min(CFG.maxZoom, maxSize * 10.0);
  const clampedDist = THREE.MathUtils.clamp(currentDist, desiredMin, desiredMax);
  const dir = camera.position.clone().sub(orbit.target).normalize();
  const newDist = THREE.MathUtils.lerp(currentDist, clampedDist, 0.12);
  camera.position.copy(orbit.target.clone().add(dir.multiplyScalar(newDist)));
  camera.lookAt(orbit.target);
  orbit.update();
}

/* =============================
   GIZMOS
============================= */
function removeGizmo() {
  if (currentGizmo) {
    scene.remove(currentGizmo);
    currentGizmo = null;
  }
}
function createTranslateGizmo() {
  const gizmo = new THREE.Group();
  const L = CFG.arrowSize;

  const ax = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), L, 0xFF3B30, 0.6, 0.4);
  ax.userData.axis = 'x';
  const ay = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), L, 0x34C759, 0.6, 0.4);
  ay.userData.axis = 'y';
  const az = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), L, 0x007AFF, 0.6, 0.4);
  az.userData.axis = 'z';

  const center = new THREE.Mesh(
    new THREE.SphereGeometry(0.3, 16, 16),
    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85, depthTest: false })
  );
  center.userData.axis = 'free';
  center.renderOrder = 999;

  gizmo.add(ax, ay, az, center);
  gizmo.traverse(c => {
    if (c.material) {
      c.material.depthTest = false;
      c.material.depthWrite = false;
      c.renderOrder = 999;
    }
  });
  return gizmo;
}
function createRotateGizmo() {
  const gizmo = new THREE.Group();
  const r = 2.0;

  const ringX = new THREE.Mesh(
    new THREE.TorusGeometry(r, 0.08, 16, 64),
    new THREE.MeshBasicMaterial({ color: 0xFF3B30, transparent: true, opacity: 0.85, depthTest: false })
  );
  ringX.rotation.y = Math.PI / 2;
  ringX.userData.axis = 'x';

  const ringY = new THREE.Mesh(
    new THREE.TorusGeometry(r, 0.08, 16, 64),
    new THREE.MeshBasicMaterial({ color: 0x34C759, transparent: true, opacity: 0.85, depthTest: false })
  );
  ringY.rotation.x = Math.PI / 2;
  ringY.userData.axis = 'y';

  const ringZ = new THREE.Mesh(
    new THREE.TorusGeometry(r, 0.08, 16, 64),
    new THREE.MeshBasicMaterial({ color: 0x007AFF, transparent: true, opacity: 0.85, depthTest: false })
  );
  ringZ.userData.axis = 'z';

  gizmo.add(ringX, ringY, ringZ);
  gizmo.traverse(c => { if (c.material) { c.material.depthTest = false; c.renderOrder = 999; }});
  return gizmo;
}
function createScaleGizmo() {
  const gizmo = new THREE.Group();
  const len = 2.0;
  const s = 0.3;

  function handle(color, axis, pos) {
    const h = new THREE.Mesh(
      new THREE.BoxGeometry(s, s, s),
      new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9, depthTest: false })
    );
    h.position.copy(pos);
    h.userData.axis = axis;
    h.renderOrder = 999;
    return h;
  }
  function line(color, a, b) {
    return new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([a, b]),
      new THREE.LineBasicMaterial({ color, depthTest: false })
    );
  }

  const hx = handle(0xFF3B30, 'x', new THREE.Vector3(len, 0, 0));
  const hy = handle(0x34C759, 'y', new THREE.Vector3(0, len, 0));
  const hz = handle(0x007AFF, 'z', new THREE.Vector3(0, 0, len));
  const hu = handle(0xffffff, 'uniform', new THREE.Vector3(0, 0, 0));

  gizmo.add(
    hx, line(0xFF3B30, new THREE.Vector3(0,0,0), new THREE.Vector3(len,0,0)),
    hy, line(0x34C759, new THREE.Vector3(0,0,0), new THREE.Vector3(0,len,0)),
    hz, line(0x007AFF, new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,len)),
    hu
  );

  gizmo.traverse(c => { if (c.material) { c.material.depthTest = false; c.material.depthWrite = false; c.renderOrder = 999; }});
  return gizmo;
}

function createGizmoFor(mode, position, targetObject) {
  removeGizmo();
  if (mode === 'translate') currentGizmo = createTranslateGizmo();
  else if (mode === 'rotate') currentGizmo = createRotateGizmo();
  else if (mode === 'scale') currentGizmo = createScaleGizmo();
  else return null;

  currentGizmo.position.copy(position);

  if (targetObject && currentSpace === 'local') currentGizmo.quaternion.copy(targetObject.quaternion);
  else currentGizmo.quaternion.identity();

  scene.add(currentGizmo);
  return currentGizmo;
}

function updateGizmoPose() {
  if (!currentGizmo || !selectedObject) return;
  const subPos = subAPI.getActiveSubWorldPos();
  if (currentMode === 'select' && subPos) currentGizmo.position.copy(subPos);
  else currentGizmo.position.copy(selectedObject.position);

  if (currentSpace === 'local') currentGizmo.quaternion.copy(selectedObject.quaternion);
  else currentGizmo.quaternion.identity();
}

/* =============================
   SELECTION VISUALS
============================= */
function setObjectSelectedVisual(obj, on) {
  if (!obj?.material) return;
  if (on) {
    obj.material.color.setHex(CFG.selColor);
    if (obj.userData.edges) {
      obj.userData.edges.material.color.setHex(CFG.selEdge);
      obj.userData.edges.material.opacity = 0.85;
    }
  } else {
    obj.material.color.setHex(obj.userData.originalColor ?? CFG.objColor);
    if (obj.userData.edges) {
      obj.userData.edges.material.color.setHex(CFG.objEdge);
      obj.userData.edges.material.opacity = 0.5;
    }
  }
}

function applySelectionUI() {
  objects.forEach(o => setObjectSelectedVisual(o, false));
  selectedObjects.forEach(o => setObjectSelectedVisual(o, true));

  if (selectedObject) {
    btnExit.classList.add('visible');
    spaceToggle.classList.add('visible');
    editValuesBtn.classList.add('visible');

    setEditMode(true);

    if (currentMode === 'select') {
      subtoolbar.classList.add('visible');
      subAPI.applySubVisibility(selectedObject);
      removeGizmo();
    } else {
      subtoolbar.classList.remove('visible');
      subAPI.clearActiveSub();
      createGizmoFor(currentMode, selectedObject.position, selectedObject);
    }

    updateEditButtonPosition();
    focusSelectedSoft();
  } else {
    btnExit.classList.remove('visible');
    spaceToggle.classList.remove('visible');
    editValuesBtn.classList.remove('visible');

    subtoolbar.classList.remove('visible');
    subAPI.clearActiveSub();
    setEditMode(false);
    removeGizmo();
  }
}

function deselectAll() {
  selectedObject = null;
  selectedObjects = [];
  multiSelectEnabled = false;
  allSelectEnabled = false;

  btnSubMulti.classList.remove('active');
  btnSubAll.classList.remove('active');

  subAPI.clearActiveSub();
  applySelectionUI();
}

/* =============================
   UI: MODE + SUBTOOLBAR
============================= */
function setMode(mode) {
  currentMode = mode;
  toolbar.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
  const btn = toolbar.querySelector(`[data-mode="${mode}"]`);
  if (btn) btn.classList.add('active');

  if (selectedObject) {
    if (currentMode === 'select') {
      subtoolbar.classList.add('visible');
      subAPI.applySubVisibility(selectedObject);
      subAPI.clearActiveSub();
      removeGizmo();
    } else {
      subtoolbar.classList.remove('visible');
      subAPI.clearActiveSub();
      createGizmoFor(currentMode, selectedObject.position, selectedObject);
    }
  }
}

function toggleMultiSelect() {
  multiSelectEnabled = !multiSelectEnabled;
  btnSubMulti.classList.toggle('active', multiSelectEnabled);
  if (!multiSelectEnabled && selectedObject) {
    selectedObjects = [selectedObject];
    applySelectionUI();
  }
}
function toggleAllSelection() {
  allSelectEnabled = !allSelectEnabled;
  btnSubAll.classList.toggle('active', allSelectEnabled);

  if (allSelectEnabled) {
    selectedObjects = [...objects];
    selectedObject = selectedObjects[0] ?? null;
  } else {
    selectedObjects = selectedObject ? [selectedObject] : [];
  }
  applySelectionUI();
}

/* =============================
   UI: THEME
============================= */
function setTheme(theme) {
  if (theme === 'dark') {
    document.body.classList.add('dark-mode');
    themeLight.classList.remove('active');
    themeDark.classList.add('active');
    scene.background = new THREE.Color(0x1c1c1e);
    scene.fog = new THREE.Fog(0x1c1c1e, 10, 220);
  } else {
    document.body.classList.remove('dark-mode');
    themeLight.classList.add('active');
    themeDark.classList.remove('active');
    scene.background = new THREE.Color(CFG.bg);
    scene.fog = new THREE.Fog(CFG.bg, 10, 220);
  }
}

/* =============================
   MEASUREMENT
============================= */
function showMeasure() {
  measurementLine.classList.add('visible');
  distanceLabel.classList.add('visible');
}
function hideMeasure() {
  measurementLine.classList.remove('visible');
  distanceLabel.classList.remove('visible');
}
function toScreenPosition(position) {
  const v = position.clone().project(camera);
  return {
    x: (v.x * 0.5 + 0.5) * window.innerWidth,
    y: (-(v.y * 0.5) + 0.5) * window.innerHeight
  };
}
function updateMeasureLine(worldPos) {
  if (!measurementLine.classList.contains('visible')) return;

  currentDistance = worldPos.distanceTo(originPosition);

  const a = toScreenPosition(originPosition);
  const b = toScreenPosition(worldPos);

  measureLine.setAttribute('x1', a.x);
  measureLine.setAttribute('y1', a.y);
  measureLine.setAttribute('x2', b.x);
  measureLine.setAttribute('y2', b.y);

  originDot.setAttribute('cx', a.x);
  originDot.setAttribute('cy', a.y);

  distanceLabel.textContent = `${currentDistance.toFixed(2)} m`;
  distanceLabel.style.left = ((a.x + b.x) / 2) + 'px';
  distanceLabel.style.top = (((a.y + b.y) / 2) - 30) + 'px';
}

/* =============================
   AXIS DIALOG
============================= */
function openAxisDialog() {
  if (!selectedObject) return;

  const titles = {
    translate: ['Posici√≥n Exacta', 'Ingresa X, Y, Z'],
    rotate: ['Rotaci√≥n Exacta', 'Grados (¬∞)'],
    scale: ['Escala Exacta', 'Factores X, Y, Z'],
    select: ['Edici√≥n', 'Selecciona subcomponentes']
  };
  const [t, s] = titles[currentMode] ?? titles.translate;
  axisTitle.textContent = t;
  axisSubtitle.textContent = s;

  if (currentMode === 'translate') {
    inputX.value = selectedObject.position.x.toFixed(2);
    inputY.value = selectedObject.position.y.toFixed(2);
    inputZ.value = selectedObject.position.z.toFixed(2);
  } else if (currentMode === 'rotate') {
    inputX.value = (selectedObject.rotation.x * 180 / Math.PI).toFixed(1);
    inputY.value = (selectedObject.rotation.y * 180 / Math.PI).toFixed(1);
    inputZ.value = (selectedObject.rotation.z * 180 / Math.PI).toFixed(1);
  } else if (currentMode === 'scale') {
    inputX.value = selectedObject.scale.x.toFixed(2);
    inputY.value = selectedObject.scale.y.toFixed(2);
    inputZ.value = selectedObject.scale.z.toFixed(2);
  } else {
    inputX.value = selectedObject.position.x.toFixed(2);
    inputY.value = selectedObject.position.y.toFixed(2);
    inputZ.value = selectedObject.position.z.toFixed(2);
  }

  axisDialog.classList.add('visible');
}
function closeAxisDialog() {
  axisDialog.classList.remove('visible');
}
function clampScale(v) {
  return Math.max(CFG.minScale, Math.min(CFG.maxScale, v));
}
btnApply.addEventListener('click', () => {
  if (!selectedObject) return;
  const before = snapshotTransform(selectedObject);

  const x = parseFloat(inputX.value);
  const y = parseFloat(inputY.value);
  const z = parseFloat(inputZ.value);
  if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) return;

  if (currentMode === 'translate') {
    selectedObject.position.set(x, y, z);
  } else if (currentMode === 'rotate') {
    selectedObject.rotation.set(x * Math.PI / 180, y * Math.PI / 180, z * Math.PI / 180);
    selectedObject.quaternion.setFromEuler(selectedObject.rotation);
  } else if (currentMode === 'scale') {
    selectedObject.scale.set(clampScale(x), clampScale(y), clampScale(z));
  } else {
    selectedObject.position.set(x, y, z);
  }

  enforceLimits(selectedObject);
  updateGizmoPose();

  const after = snapshotTransform(selectedObject);
  pushAction({ type: 'transform', id: selectedObject.userData.id, before, after });
  closeAxisDialog();
});
btnClose.addEventListener('click', closeAxisDialog);

/* =============================
   CONFIRM MINI
============================= */
function showConfirm() { confirmDialog.classList.add('visible'); }
function hideConfirm() { confirmDialog.classList.remove('visible'); }
btnCancel.addEventListener('click', () => {
  // cancelar: no deshace autom√°ticamente, pero cierra y permite seguir
  hideConfirm();
  subAPI.clearActiveSub();
  if (selectedObject && currentMode !== 'select') createGizmoFor(currentMode, selectedObject.position, selectedObject);
});
btnOk.addEventListener('click', () => {
  hideConfirm();
  // commit sub edit si aplica
  subAPI.commitSubEditIfAny((action) => pushAction(action));
  subAPI.clearActiveSub();
});

/* =============================
   OBJECT CREATION
============================= */
function createTechTexture() {
  const c = document.createElement('canvas');
  c.width = 512; c.height = 512;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#f0f0f5';
  ctx.fillRect(0, 0, 512, 512);
  ctx.strokeStyle = '#d1d1d6';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i <= 512; i += 64) {
    ctx.moveTo(i, 0); ctx.lineTo(i, 512);
    ctx.moveTo(0, i); ctx.lineTo(512, i);
  }
  ctx.stroke();
  const t = new THREE.CanvasTexture(c);
  t.wrapS = t.wrapT = THREE.RepeatWrapping;
  return t;
}

function createPrimitive(type, id) {
  let geo;
  if (type === 'box') geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
  else if (type === 'sphere') geo = new THREE.SphereGeometry(0.9, 48, 48);
  else if (type === 'cylinder') geo = new THREE.CylinderGeometry(0.8, 0.8, 1.8, 48);
  else if (type === 'cone') geo = new THREE.ConeGeometry(0.9, 2.0, 48);
  else if (type === 'torus') geo = new THREE.TorusGeometry(1.0, 0.28, 24, 80);
  else if (type === 'plane') geo = new THREE.PlaneGeometry(3.5, 3.5, 1, 1);
  else geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);

  const mat = new THREE.MeshStandardMaterial({
    color: CFG.objColor, roughness: 0.45, metalness: 0.08,
    side: THREE.DoubleSide
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;

  mesh.userData.id = id;
  mesh.userData.originalColor = CFG.objColor;

  const edges = new THREE.LineSegments(
    new THREE.EdgesGeometry(geo),
    new THREE.LineBasicMaterial({ color: CFG.objEdge, transparent: true, opacity: 0.5 })
  );
  mesh.add(edges);
  mesh.userData.edges = edges;

  if (type === 'plane') {
    mesh.rotation.x = -Math.PI / 2;
    mesh.quaternion.setFromEuler(mesh.rotation);
    mesh.position.y = 0.02;
  }
  return mesh;
}

function spawn(type) {
  const id = nextObjectId++;
  const mesh = createPrimitive(type, id);

  mesh.position.set((Math.random() - 0.5) * 2, 0.75, (Math.random() - 0.5) * 2);

  scene.add(mesh);
  objects.push(mesh);
  applyRenderMode(mesh, currentRenderMode);

  pushAction({
    type: 'add',
    items: [{ prim: { type, id }, state: snapshotTransform(mesh) }]
  });
}

/* =============================
   RENDER MODE
============================= */
function applyRenderMode(mesh, mode) {
  const m = mesh.material;
  const e = mesh.userData.edges;

  if (mode === 'flat') {
    m.map = null;
    m.roughness = 0.45;
    if (!selectedObjects.includes(mesh)) m.color.setHex(mesh.userData.originalColor ?? CFG.objColor);
    if (e) e.visible = true;
  } else if (mode === 'clay') {
    m.map = null;
    m.roughness = 1.0;
    if (!selectedObjects.includes(mesh)) m.color.setHex(0xd0d0d5);
    if (e) e.visible = false;
  } else if (mode === 'tech') {
    m.map = gridTexture;
    m.roughness = 0.55;
    if (!selectedObjects.includes(mesh)) m.color.setHex(0xffffff);
    if (e) e.visible = true;
  }
  m.needsUpdate = true;
}

/* =============================
   DELETE / COLOR
============================= */
btnDelete.addEventListener('click', () => {
  if (!selectedObjects.length) return;

  const ids = selectedObjects.map(o => o.userData.id);
  const items = selectedObjects.map(o => ({
    prim: { type: o.userData.primType ?? 'box', id: o.userData.id },
    state: snapshotTransform(o)
  }));

  pushAction({ type: 'delete', ids, items });

  const toRemove = [...selectedObjects];
  deselectAll();
  toRemove.forEach(o => removeObjectFromScene(o));
});

btnColor.addEventListener('click', () => {
  if (!selectedObjects.length) return;
  selectedObjects.forEach(o => {
    const c = Math.random() * 0xffffff;
    o.material.color.setHex(c);
    o.userData.originalColor = c;
  });
  applySelectionUI();
});

/* =============================
   LIMITS
============================= */
function enforceLimits(obj) {
  if (!obj) return;

  if (obj.position.length() > CFG.maxDistance) obj.position.setLength(CFG.maxDistance);
  if (obj.position.y < 0) obj.position.y = 0;

  obj.scale.x = clampScale(obj.scale.x);
  obj.scale.y = clampScale(obj.scale.y);
  obj.scale.z = clampScale(obj.scale.z);
}

/* =============================
   HANDLE PICKING
============================= */
function getIntersectedHandle(x, y) {
  if (!currentGizmo) return null;

  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((y - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const handles = [];
  currentGizmo.traverse(child => { if (child.isMesh || child.isLine) handles.push(child); });
  const hits = raycaster.intersectObjects(handles, true);
  if (!hits.length) return null;

  let o = hits[0].object;
  while (o.parent && o.parent !== currentGizmo) o = o.parent;
  return o;
}

/* =============================
   OBJECT / SUBCOMPONENT DRAG
============================= */
function rotateWorld(obj, worldAxis, angle) {
  const q = new THREE.Quaternion().setFromAxisAngle(worldAxis, angle);
  obj.quaternion.premultiply(q);
  obj.rotation.setFromQuaternion(obj.quaternion);
}

function saveOriginState() {
  const subPos = subAPI.getActiveSubWorldPos();
  if (subPos) originPosition.copy(subPos);
  else if (selectedObject) originPosition.copy(selectedObject.position);
}

function manipulateByGizmo(x, y) {
  if (!activeHandle) return;
  const axis = activeHandle.userData.axis;

  // 1) subcomponent translate (handled by submodule)
  if (currentMode === 'select' && selectedObject && subAPI.hasActiveSub()) {
    if (!dragState) return;
    const hit = intersectPlane(x, y, dragState.plane);
    if (!hit) return;

    let worldDelta = hit.clone().sub(dragState.startHit);
    if (dragState.axisDirW) {
      const s = worldDelta.dot(dragState.axisDirW);
      worldDelta = dragState.axisDirW.clone().multiplyScalar(s);
    }

    const movedDistance = subAPI.applySubTranslateWorldDelta(selectedObject, worldDelta);
    updateGizmoPose();

    const subPos = subAPI.getActiveSubWorldPos();
    if (subPos) updateMeasureLine(subPos);

    updateIntelligentZoomFromMoved(movedDistance);

    dragState.startHit.copy(hit);
    dragStart.set(x, y);
    return;
  }

  // 2) object transforms
  if (!selectedObject) return;

  if (currentMode === 'translate') {
    if (!dragState) return;
    const hit = intersectPlane(x, y, dragState.plane);
    if (!hit) return;

    let worldDelta = hit.clone().sub(dragState.startHit);
    if (dragState.axisDirW) {
      const s = worldDelta.dot(dragState.axisDirW);
      worldDelta = dragState.axisDirW.clone().multiplyScalar(s);
    }

    selectedObject.position.add(worldDelta);
    enforceLimits(selectedObject);

    const moved = selectedObject.position.distanceTo(originPosition);
    updateMeasureLine(selectedObject.position);
    updateIntelligentZoomFromMoved(moved);

    updateGizmoPose();

    dragState.startHit.copy(hit);
    dragStart.set(x, y);

  } else if (currentMode === 'rotate') {
    const rotScale = 0.02;
    const delta = (x - dragStart.x + y - dragStart.y) * rotScale;
    if (axis === 'x' || axis === 'y' || axis === 'z') {
      const ax = axisToVec(axis);
      if (currentSpace === 'local') selectedObject.rotateOnAxis(ax, delta);
      else rotateWorld(selectedObject, ax, delta);
    }
    updateGizmoPose();
    dragStart.set(x, y);

  } else if (currentMode === 'scale') {
    const scaleSpeed = 0.01;
    const delta = (dragStart.y - y) * scaleSpeed; // ‚úÖ up grows
    if (axis === 'x') selectedObject.scale.x = clampScale(selectedObject.scale.x + delta);
    else if (axis === 'y') selectedObject.scale.y = clampScale(selectedObject.scale.y + delta);
    else if (axis === 'z') selectedObject.scale.z = clampScale(selectedObject.scale.z + delta);
    else if (axis === 'uniform') {
      const s = clampScale(selectedObject.scale.x + delta);
      selectedObject.scale.set(s, s, s);
    }
    updateGizmoPose();
    dragStart.set(x, y);
  }
}

/* =============================
   DOUBLE TAP: select object or subcomponent
============================= */
function toggleInMultiSelection(obj) {
  const i = selectedObjects.indexOf(obj);
  if (i >= 0) selectedObjects.splice(i, 1);
  else selectedObjects.push(obj);
}

function handleDoubleTap(x, y) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((y - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  // subcomponents first (in select mode)
  if (currentMode === 'select' && selectedObject) {
    const picked = subAPI.pickSubcomponent(raycaster, selectedObject);
    if (picked) {
      subAPI.setActiveSub(picked);
      createGizmoFor('translate', picked.worldPos, selectedObject);
      showConfirm();
      setEditMode(true);
      return;
    }
  }

  // object pick
  const hits = raycaster.intersectObjects(objects, false);
  if (hits.length) {
    const hit = hits[0].object;

    if (multiSelectEnabled) {
      toggleInMultiSelection(hit);
      selectedObject = hit;
      if (!selectedObjects.includes(hit)) selectedObjects.push(hit);
    } else {
      selectedObject = hit;
      selectedObjects = [hit];
    }
    applySelectionUI();
  } else {
    if (!multiSelectEnabled) deselectAll();
  }
}

/* =============================
   POINTER EVENTS
============================= */
function setupPointerEvents() {
  const canvas = renderer.domElement;

  canvas.addEventListener('pointerdown', (e) => {
    touchStart.set(e.clientX, e.clientY);
    dragStart.set(e.clientX, e.clientY);

    // try handle
    if (currentGizmo) {
      const h = getIntersectedHandle(e.clientX, e.clientY);
      if (h) {
        activeHandle = h;
        isDragging = true;

        // freeze camera while dragging gizmo
        orbit.enableZoom = false;
        orbit.enableRotate = false;
        orbit.enablePan = false;

        saveOriginState();

        // begin translate plane if needed
        const axis = activeHandle.userData.axis;

        const box = selectedObject ? new THREE.Box3().setFromObject(selectedObject) : null;
        const centerW = box ? box.getCenter(new THREE.Vector3()) : (selectedObject ? selectedObject.position.clone() : new THREE.Vector3());
        const size = box ? box.getSize(new THREE.Vector3()) : new THREE.Vector3(1, 1, 1);
        const radius = Math.max(size.x, size.y, size.z) * 0.55;

        const subPos = subAPI.getActiveSubWorldPos();
        const anchorW = subPos ? subPos.clone() : (currentGizmo ? currentGizmo.position.clone() : centerW.clone());

        if (currentMode === 'translate' || (currentMode === 'select' && subAPI.hasActiveSub())) {
          beginTranslateDrag(axis, anchorW, centerW, radius);
          showMeasure();
          updateMeasureLine(anchorW);
        } else {
          dragState = null;
        }

        return;
      }
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (isDragging && activeHandle) {
      manipulateByGizmo(e.clientX, e.clientY);
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    const dist = Math.hypot(e.clientX - touchStart.x, e.clientY - touchStart.y);

    if (isDragging) {
      isDragging = false;
      activeHandle = null;
      dragState = null;
      hideMeasure();

      // restore locks
      if (isEditMode) applyCameraLocks();
      else { orbit.enableZoom = true; orbit.enableRotate = true; orbit.enablePan = true; }

      // push transform action (for objects only) if we were not in sub selection
      if (selectedObject && currentMode !== 'select') {
        // record transform on mouse-up if changed
        // (simple strategy: we snapshot at down? for brevity, we capture from originPosition not enough)
        // We'll do a safe minimal: always push "transform" for object edits by comparing last saved snapshot.
        // To keep it robust, store a "dragBeforeSnap" in userData.
        const before = selectedObject.userData._dragBefore;
        if (before) {
          const after = snapshotTransform(selectedObject);
          const changed =
            before.pos.some((v, i) => Math.abs(v - after.pos[i]) > 1e-6) ||
            before.quat.some((v, i) => Math.abs(v - after.quat[i]) > 1e-6) ||
            before.scl.some((v, i) => Math.abs(v - after.scl[i]) > 1e-6);

          if (changed) pushAction({ type: 'transform', id: selectedObject.userData.id, before, after });
          delete selectedObject.userData._dragBefore;
        }
      }

      showConfirm();
      return;
    }

    if (dist < 15) {
      const now = Date.now();
      if (now - lastTapTime < 400) {
        handleDoubleTap(e.clientX, e.clientY);
        lastTapTime = 0;
      } else {
        lastTapTime = now;
      }
    }
  });
}

/* =============================
   MISC UI
============================= */
function updateEditButtonPosition() {
  if (!selectedObject || !editValuesBtn.classList.contains('visible')) return;
  const p = selectedObject.position.clone();
  p.x += 3.5; p.y += 1.0;
  const s = toScreenPosition(p);
  editValuesBtn.style.left = s.x + 'px';
  editValuesBtn.style.top = s.y + 'px';
  editValuesBtn.style.transform = 'translate(-50%,-50%)';
}

/* =============================
   INIT
============================= */
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(CFG.bg);
  scene.fog = new THREE.Fog(CFG.bg, 10, 220);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
  camera.position.set(5, 6, 8);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.HemisphereLight(0xffffff, 0xffffff, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 1.5);
  dir.position.set(5, 15, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048, 2048);
  dir.shadow.camera.left = -60;
  dir.shadow.camera.right = 60;
  dir.shadow.camera.top = 60;
  dir.shadow.camera.bottom = -60;
  scene.add(dir);

  scene.add(new THREE.GridHelper(160, 160, 0xc7c7cc, 0xe5e5ea));
  const axes = new THREE.AxesHelper(2.8);
  axes.material.depthTest = false;
  axes.renderOrder = 1;
  scene.add(axes);

  gridTexture = createTechTexture();

  orbit = new OrbitControls(camera, renderer.domElement);
  orbit.enableDamping = true;
  orbit.dampingFactor = 0.05;
  orbit.maxPolarAngle = Math.PI / 2 - 0.05;
  orbit.minDistance = CFG.minZoom;
  orbit.maxDistance = CFG.maxZoom;

  // Subcomponent module setup (gets full access through API)
  subAPI = setupSubcomponents({
    THREE,
    CFG,
    scene,
    camera,
    renderer,
    raycaster,
    mouse,
    pushAction,          // so it can create actions if needed
    updateGizmoPose,     // to refresh gizmo when sub moves
    applyRenderMode,
    getSelectedObject: () => selectedObject,
    isMobile: () => IS_MOBILE
  });

  setupPointerEvents();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // theme
  themeLight.addEventListener('click', () => setTheme('light'));
  themeDark.addEventListener('click', () => setTheme('dark'));

  // overlay start
  btnStart.addEventListener('click', () => {
    overlay.style.opacity = 0;
    setTimeout(() => overlay.style.display = 'none', 450);
    spawn('box');
  });

  // render mode buttons
  renderBar.querySelectorAll('[data-render]').forEach(btn => {
    btn.addEventListener('click', () => {
      renderBar.querySelectorAll('[data-render]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const mode = btn.dataset.render;
      currentRenderMode = (mode === 'flat') ? 'flat' : (mode === 'clay') ? 'clay' : 'tech';
      objects.forEach(o => applyRenderMode(o, currentRenderMode));
    });
  });

  // camera buttons
  cameraBar.querySelectorAll('[data-cam]').forEach(btn => {
    btn.addEventListener('click', () => {
      const c = btn.dataset.cam;
      if (c === 'fitall') fitAll();
      else if (c === 'focus') focusSelected();
      else snapView(c);
    });
  });

  // toolbar (spawn/modes)
  toolbar.querySelectorAll('[data-spawn]').forEach(btn => {
    btn.addEventListener('click', () => spawn(btn.dataset.spawn));
  });
  toolbar.querySelectorAll('[data-mode]').forEach(btn => {
    btn.addEventListener('click', () => setMode(btn.dataset.mode));
  });

  // subtoolbar
  btnSubMulti.addEventListener('click', toggleMultiSelect);
  btnSubAll.addEventListener('click', toggleAllSelection);
  btnSubVerts.addEventListener('click', () => { btnSubVerts.classList.toggle('active'); subAPI.setSubFlagsFromUI(); });
  btnSubEdges.addEventListener('click', () => { btnSubEdges.classList.toggle('active'); subAPI.setSubFlagsFromUI(); });
  btnSubFaces.addEventListener('click', () => { btnSubFaces.classList.toggle('active'); subAPI.setSubFlagsFromUI(); });

  // exit
  btnExit.addEventListener('click', () => deselectAll());

  // space toggle
  spaceToggle.addEventListener('click', () => {
    currentSpace = (currentSpace === 'world') ? 'local' : 'world';
    spaceToggle.classList.toggle('local', currentSpace === 'local');
    spaceIcon.textContent = (currentSpace === 'local') ? 'üìç' : 'üåç';
    spaceText.textContent = (currentSpace === 'local') ? 'Local' : 'Global';

    if (selectedObject) {
      if (currentMode !== 'select') createGizmoFor(currentMode, selectedObject.position, selectedObject);
      else {
        const sp = subAPI.getActiveSubWorldPos();
        if (sp) createGizmoFor('translate', sp, selectedObject);
      }
    }
  });

  // edit-values
  editValuesBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    openAxisDialog();
  });

  // store before snapshot at gizmo drag start for transform actions
  renderer.domElement.addEventListener('pointerdown', () => {
    if (selectedObject) selectedObject.userData._dragBefore = snapshotTransform(selectedObject);
  }, { passive: true });

  updateUndoRedoUI();
}

/* =============================
   SELECTION (object) ‚Äî performed by submodule? no, here.
   We let double-tap handle selection.
   Multi selection is handled in handleDoubleTap.
============================= */

/* =============================
   ANIMATE
============================= */
let subAPI = null;

function animate() {
  requestAnimationFrame(animate);

  if (selectedObject && editValuesBtn.classList.contains('visible')) updateEditButtonPosition();
  if (selectedObject && currentMode === 'select') subAPI.applySubVisibility(selectedObject);

  orbit.update();
  renderer.render(scene, camera);
}

/* =============================
   BOOT
============================= */
init();
animate();

/* =============================
   Expose a minimal debug API (optional)
============================= */
window._mr = {
  get scene() { return scene; },
  get camera() { return camera; },
  get objects() { return objects; }
};
/* ============================================================
   Subcomponents module: vertices / edges / faces selection + edit
   - Works with core by receiving an API object (setupSubcomponents)
   - Implements:
     - toggles: verts/edges/faces
     - picking (double tap)
     - moving subcomponents using world delta from core plane drag
     - commit action for undo/redo
============================================================ */

export function setupSubcomponents(api) {
  const {
    THREE, CFG, scene, camera, renderer,
    raycaster, mouse,
    getSelectedObject,
    isMobile
  } = api;

  // Read UI toggles from DOM each click
  const btnV = document.getElementById('sub-verts');
  const btnE = document.getElementById('sub-edges');
  const btnF = document.getElementById('sub-faces');

  let subModeVerts = false;
  let subModeEdges = false;
  let subModeFaces = false;

  let activeSub = null;
  // { type:'vertex'|'edge'|'face', indices:[...], worldPos:Vector3, accLocal?:Vector3 }

  function setSubFlagsFromUI() {
    subModeVerts = btnV.classList.contains('active');
    subModeEdges = btnE.classList.contains('active');
    subModeFaces = btnF.classList.contains('active');

    const obj = getSelectedObject();
    if (obj) applySubVisibility(obj);
  }

  function ensureSubHelpers(obj) {
    if (!obj || !obj.geometry) return;
    if (!obj.userData.sub) obj.userData.sub = {};

    // Vert points
    if (!obj.userData.sub.vertexPoints) {
      const geom = obj.geometry;
      const posAttr = geom.attributes.position;

      const ptsGeo = new THREE.BufferGeometry();
      ptsGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(posAttr.array), 3));

      const col = new Float32Array(posAttr.count * 3);
      for (let i = 0; i < posAttr.count; i++) {
        col[i*3+0] = 1; col[i*3+1] = 1; col[i*3+2] = 1;
      }
      ptsGeo.setAttribute('color', new THREE.BufferAttribute(col, 3));

      const ptsMat = new THREE.PointsMaterial({
        size: 0.10,
        vertexColors: true,
        depthTest: false,
        transparent: true,
        opacity: 0.95
      });

      const pts = new THREE.Points(ptsGeo, ptsMat);
      pts.renderOrder = 998;
      pts.visible = false;
      pts.name = 'VertexPoints';
      obj.add(pts);
      obj.userData.sub.vertexPoints = pts;
    }

    // Edges helper
    if (!obj.userData.sub.edgeLines) {
      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(obj.geometry),
        new THREE.LineBasicMaterial({ color: CFG.subColorB, transparent: true, opacity: 0.55, depthTest: false })
      );
      edges.visible = false;
      edges.renderOrder = 997;
      edges.name = 'EdgeLines';
      obj.add(edges);
      obj.userData.sub.edgeLines = edges;
    }

    // Face wire helper
    if (!obj.userData.sub.faceWire) {
      const wire = new THREE.LineSegments(
        new THREE.WireframeGeometry(obj.geometry),
        new THREE.LineBasicMaterial({ color: CFG.subColorB, transparent: true, opacity: 0.35, depthTest: false })
      );
      wire.visible = false;
      wire.renderOrder = 996;
      wire.name = 'FaceWire';
      obj.add(wire);
      obj.userData.sub.faceWire = wire;
    }
  }

  function refreshSubMeshes(obj) {
    if (!obj?.userData?.sub) return;

    // update points positions
    const pts = obj.userData.sub.vertexPoints;
    if (pts) {
      const src = obj.geometry.attributes.position.array;
      const dst = pts.geometry.attributes.position;
      dst.array.set(src);
      dst.needsUpdate = true;
    }

    // rebuild edges and wire
    if (obj.userData.sub.edgeLines) {
      obj.remove(obj.userData.sub.edgeLines);
      obj.userData.sub.edgeLines.geometry.dispose();
      obj.userData.sub.edgeLines.material.dispose();
      obj.userData.sub.edgeLines = null;
    }
    if (obj.userData.sub.faceWire) {
      obj.remove(obj.userData.sub.faceWire);
      obj.userData.sub.faceWire.geometry.dispose();
      obj.userData.sub.faceWire.material.dispose();
      obj.userData.sub.faceWire = null;
    }

    ensureSubHelpers(obj);
    applySubVisibility(obj);
  }

  function applySubVisibility(obj) {
    ensureSubHelpers(obj);
    const show = (getSelectedObject() === obj);

    obj.userData.sub.vertexPoints.visible = show && subModeVerts;
    obj.userData.sub.edgeLines.visible = show && subModeEdges;
    obj.userData.sub.faceWire.visible = show && subModeFaces;
  }

  function clearActiveSub() {
    activeSub = null;
  }
  function hasActiveSub() { return !!activeSub; }
  function getActiveSubWorldPos() {
    return activeSub?.worldPos || null;
  }
  function setActiveSub(sub) {
    activeSub = sub;
    if (!activeSub) return;
    activeSub.accLocal = new THREE.Vector3();
    // En subcomponent selection: conviene ‚Äúfocus‚Äù a objeto completo (core ya tiene focus button)
  }

  // Highlight helpers
  function highlightVertex(obj, idx) {
    ensureSubHelpers(obj);
    const pts = obj.userData.sub.vertexPoints;
    const col = pts.geometry.attributes.color;
    for (let i=0; i<col.count; i++) col.setXYZ(i, 1,1,1);
    col.setXYZ(idx, 0.2, 1.0, 0.4); // greenish
    col.needsUpdate = true;
  }
  function highlightEdge(obj) {
    ensureSubHelpers(obj);
    obj.userData.sub.edgeLines.material.opacity = 0.9;
    obj.userData.sub.edgeLines.material.color.setHex(CFG.subColorA);
  }
  function highlightFace(obj) {
    ensureSubHelpers(obj);
    obj.userData.sub.faceWire.material.opacity = 0.75;
    obj.userData.sub.faceWire.material.color.setHex(CFG.subColorA);
  }

  // Approx edge by nearest two vertices (simple but works)
  function approximateEdgeByNearest(obj, worldPoint) {
    const geom = obj.geometry;
    const pos = geom.attributes.position;
    const local = obj.worldToLocal(worldPoint.clone());

    let best = -1, bestD = Infinity;
    for (let i=0; i<pos.count; i++){
      const dx = pos.getX(i) - local.x;
      const dy = pos.getY(i) - local.y;
      const dz = pos.getZ(i) - local.z;
      const d = dx*dx + dy*dy + dz*dz;
      if (d < bestD){ bestD = d; best = i; }
    }
    if (best < 0) return null;

    let best2 = -1, bestD2 = Infinity;
    for (let i=0; i<pos.count; i++){
      if (i === best) continue;
      const dx = pos.getX(i) - local.x;
      const dy = pos.getY(i) - local.y;
      const dz = pos.getZ(i) - local.z;
      const d = dx*dx + dy*dy + dz*dz;
      if (d < bestD2){ bestD2 = d; best2 = i; }
    }
    if (best2 < 0) return null;
    return [best, best2];
  }

  function getSubCentroidLocal(obj, indices) {
    const pos = obj.geometry.attributes.position;
    const c = new THREE.Vector3();
    for (const i of indices){
      c.x += pos.getX(i);
      c.y += pos.getY(i);
      c.z += pos.getZ(i);
    }
    c.multiplyScalar(1 / Math.max(1, indices.length));
    return c;
  }

  // Apply local delta to indices
  function applyVertexDeltaLocal(obj, indices, dLocal) {
    const geom = obj.geometry;
    const pos = geom.attributes.position;
    for (const i of indices) {
      pos.setXYZ(i,
        pos.getX(i) + dLocal.x,
        pos.getY(i) + dLocal.y,
        pos.getZ(i) + dLocal.z
      );
    }
    pos.needsUpdate = true;
    geom.computeVertexNormals();
    geom.computeBoundingBox();
    geom.computeBoundingSphere();
  }

  // Used by undo/redo actions
  function applyVertexEditForward(action) {
    const obj = api.getSelectedObject ? api.getSelectedObject() : null;
    // safer: find by id using core method if exposed? not available here
    // We'll locate through scene traversal:
    const mesh = findObjectById(action.id);
    if (!mesh) return;

    applyVertexDeltaLocal(mesh, action.indices, new THREE.Vector3(action.delta.x, action.delta.y, action.delta.z));
    refreshSubMeshes(mesh);
  }
  function applyVertexEditInverse(action) {
    const mesh = findObjectById(action.id);
    if (!mesh) return;

    applyVertexDeltaLocal(mesh, action.indices, new THREE.Vector3(-action.delta.x, -action.delta.y, -action.delta.z));
    refreshSubMeshes(mesh);
  }
  function findObjectById(id) {
    let found = null;
    scene.traverse(o => {
      if (o?.userData?.id === id) found = o;
    });
    return found;
  }

  // Picking (called by core on double tap)
  function pickSubcomponent(raycaster, obj) {
    ensureSubHelpers(obj);

    // VERTEX pick
    if (subModeVerts && obj.userData.sub.vertexPoints) {
      const hits = raycaster.intersectObject(obj.userData.sub.vertexPoints, true);
      if (hits.length) {
        const hit = hits[0];
        const idx = hit.index;
        const world = hit.point.clone();
        highlightVertex(obj, idx);
        return { type: 'vertex', indices: [idx], worldPos: world };
      }
    }

    // EDGE pick
    if (subModeEdges && obj.userData.sub.edgeLines) {
      const hits = raycaster.intersectObject(obj.userData.sub.edgeLines, true);
      if (hits.length) {
        const p = hits[0].point.clone();
        const pair = approximateEdgeByNearest(obj, p);
        if (pair) {
          highlightEdge(obj);
          return { type: 'edge', indices: pair, worldPos: p };
        }
      }
    }

    // FACE pick (raycast mesh)
    if (subModeFaces) {
      const hits = raycaster.intersectObject(obj, false);
      if (hits.length) {
        const h = hits[0];
        const face = h.face;
        const tri = [face.a, face.b, face.c];
        highlightFace(obj);
        return { type: 'face', indices: tri, worldPos: h.point.clone() };
      }
    }

    return null;
  }

  // Called by core during plane drag: world delta -> local delta, apply, update activeSub world pos
  function applySubTranslateWorldDelta(obj, worldDelta) {
    if (!activeSub) return 0;

    // exact world->local delta:
    const p0 = obj.worldToLocal(obj.position.clone());
    const p1 = obj.worldToLocal(obj.position.clone().add(worldDelta));
    const dLocal = p1.sub(p0);

    applyVertexDeltaLocal(obj, activeSub.indices, dLocal);
    refreshSubMeshes(obj);

    // accumulate for commit (undo/redo)
    activeSub.accLocal.add(dLocal);

    // update activeSub worldPos to new centroid
    const newWorld = obj.localToWorld(getSubCentroidLocal(obj, activeSub.indices));
    const movedDistance = newWorld.distanceTo(activeSub.worldPos);
    activeSub.worldPos.copy(newWorld);

    return movedDistance;
  }

  // Commit as an undoable action (called by core when OK pressed)
  function commitSubEditIfAny(pushActionFn) {
    if (!activeSub || !activeSub.accLocal) return;

    const d = activeSub.accLocal.clone();
    if (d.lengthSq() < 1e-10) return;

    const obj = getSelectedObject();
    if (!obj) return;

    pushActionFn({
      type: 'vertexEdit',
      id: obj.userData.id,
      indices: activeSub.indices.slice(),
      delta: { x: d.x, y: d.y, z: d.z }
    });

    // reset accumulator
    activeSub.accLocal.set(0, 0, 0);
  }

  // Public API for core
  return {
    setSubFlagsFromUI,
    ensureSubHelpers,
    refreshSubMeshes,
    applySubVisibility,
    pickSubcomponent,
    setActiveSub,
    clearActiveSub,
    hasActiveSub,
    getActiveSubWorldPos,
    applySubTranslateWorldDelta,
    commitSubEditIfAny,

    // undo/redo hooks
    applyVertexEditForward,
    applyVertexEditInverse
  };
}