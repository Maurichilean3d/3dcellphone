<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Blender Lite Touch</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #2b2b2b; font-family: 'Inter', sans-serif; touch-action: none; }
        
        /* UI ESTILO BLENDER */
        .toolbar {
            position: absolute; display: flex; gap: 10px; background: #333; padding: 8px;
            border-radius: 8px; border: 1px solid #444; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            pointer-events: auto; backdrop-filter: blur(4px);
        }

        #top-bar { top: 15px; left: 50%; transform: translateX(-50%); }
        #bottom-bar { bottom: 30px; left: 50%; transform: translateX(-50%); flex-wrap: wrap; justify-content: center; width: 90%; }

        .btn {
            width: 40px; height: 40px; border: none; border-radius: 4px; background: transparent;
            color: #ccc; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 10px; font-weight: 600; transition: 0.1s;
        }
        
        .btn svg { width: 24px; height: 24px; fill: currentColor; margin-bottom: 2px; }
        .btn:hover { background: #444; color: white; }
        .btn.active { background: #4772b3; color: white; } /* Azul Blender */
        
        /* Botones de Acción (Texto + Icono) */
        .action-btn {
            width: auto; padding: 0 15px; background: #444; height: 45px;
            border-left: 2px solid #555;
        }
        .action-btn:active { transform: translateY(2px); background: #222; }

        /* Colores de Herramientas */
        .btn-extrude { color: #f1c40f; }
        .btn-delete { color: #e74c3c; }

        #stats {
            position: absolute; top: 10px; left: 10px; color: #666; font-size: 10px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="stats">Poly Count: <span id="poly-count">12</span> tris</div>

    <div id="top-bar" class="toolbar">
        <button class="btn" id="mode-vertex" title="Vértices">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>
        </button>
        <button class="btn" id="mode-edge" title="Bordes">
            <svg viewBox="0 0 24 24"><path d="M4 20L20 4" stroke="currentColor" stroke-width="4" stroke-linecap="round"/></svg>
        </button>
        <button class="btn active" id="mode-face" title="Caras">
            <svg viewBox="0 0 24 24"><path d="M4 4h16v16H4z"/></svg>
        </button>
    </div>

    <div id="bottom-bar" class="toolbar">
        <button class="btn action-btn btn-extrude" id="tool-extrude">
            <span>EXTRUIR</span>
        </button>
        <button class="btn action-btn" id="tool-inset">
            <span>INSERTAR</span>
        </button>
        <div style="width:1px; background:#555; margin:0 5px;"></div>
        <button class="btn action-btn btn-delete" id="tool-delete">
            <span>BORRAR</span>
        </button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://ga.jspm.io/npm:three@0.160.0/build/three.module.js",
            "three/addons/": "https://ga.jspm.io/npm:three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2b2b2b); // Gris Blender
        scene.add(new THREE.GridHelper(20, 20, 0x444444, 0x353535));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 5, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Luz de estudio
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- 2. GEOMETRÍA DINÁMICA ---
        // Usamos arrays planos para manipular la "sopa de triángulos" fácilmente
        let geometry = new THREE.BoxGeometry(2, 2, 2).toNonIndexed();
        
        // Material "Clay" con Wireframe overlay
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x808080, roughness: 0.5, metalness: 0.1,
            polygonOffset: true, polygonOffsetFactor: 1 
        });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Wireframe persistente
        let wireframe = new THREE.LineSegments(
            new THREE.EdgesGeometry(geometry),
            new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 2 })
        );
        mesh.add(wireframe);

        // --- 3. SISTEMA DE SELECCIÓN (HANDLES) ---
        const helperGroup = new THREE.Group();
        scene.add(helperGroup);
        
        let handles = [];
        let selection = null; // Objeto seleccionado actual

        // Genera puntos de control basados en la topología actual
        function rebuildHandles(mode = 'face') {
            helperGroup.clear();
            handles = [];
            selection = null;
            transform.detach();

            const pos = geometry.attributes.position;
            const count = pos.count;

            if (mode === 'face') {
                // Generar centroide por cada 2 triángulos (1 quad)
                // Asumimos estructura quad-based (cada 6 vértices hacen un quad visual)
                for(let i=0; i<count; i+=6) {
                    const center = new THREE.Vector3();
                    // Promediar los 6 vértices del quad (2 tris)
                    for(let j=0; j<6; j++) {
                        center.add(new THREE.Vector3().fromBufferAttribute(pos, i+j));
                    }
                    center.divideScalar(6);

                    // Normal de la cara (para orientar el gizmo)
                    const p1 = new THREE.Vector3().fromBufferAttribute(pos, i);
                    const p2 = new THREE.Vector3().fromBufferAttribute(pos, i+1);
                    const p3 = new THREE.Vector3().fromBufferAttribute(pos, i+2);
                    const normal = new THREE.Vector3().subVectors(p3, p1).cross(new THREE.Vector3().subVectors(p2, p1)).normalize();

                    createHandle('face', center, normal, [i, i+1, i+2, i+3, i+4, i+5]);
                }
            }
            else if (mode === 'vertex') {
                // Agrupar vértices espaciales
                const unique = {};
                for(let i=0; i<count; i++) {
                    const v = new THREE.Vector3().fromBufferAttribute(pos, i);
                    const key = v.toArray().map(n=>n.toFixed(3)).join(',');
                    if(!unique[key]) unique[key] = [];
                    unique[key].push(i);
                }
                for(const key in unique) {
                    const indices = unique[key];
                    const v = new THREE.Vector3().fromBufferAttribute(pos, indices[0]);
                    createHandle('vertex', v, null, indices);
                }
            }
            
            updatePolyCount();
        }

        function createHandle(type, pos, normal, indices) {
            const geo = type === 'face' ? new THREE.PlaneGeometry(0.4, 0.4) : new THREE.SphereGeometry(0.15);
            const mat = new THREE.MeshBasicMaterial({ 
                color: type === 'face' ? 0x3498db : 0xffffff, 
                side: THREE.DoubleSide, depthTest: false, transparent: true, opacity: 0.5 
            });
            const h = new THREE.Mesh(geo, mat);
            h.position.copy(pos);
            if (normal) h.lookAt(pos.clone().add(normal));
            
            h.userData = { type, indices, normal };
            helperGroup.add(h);
            handles.push(h);
        }

        // --- 4. HERRAMIENTAS DE MODELADO (LA MAGIA) ---

        // EXTRUIR: Crea nueva geometría a partir de una cara
        function extrudeFace() {
            if (!selection || selection.userData.type !== 'face') {
                alert("Selecciona una CARA primero");
                return;
            }

            const indices = selection.userData.indices; // 6 índices (2 tris)
            const posAttr = geometry.attributes.position;
            const oldArray = Array.from(posAttr.array);
            
            // 1. Obtener vértices de la cara seleccionada (Base)
            // Asumimos Quad: v0, v1, v2 (tri1) y v2, v1, v3 (tri2) -> Corners: v0, v1, v2, v3
            // En geometría non-indexed plana: 0,1,2 y 3,4,5. (Donde 3=2, 4=1, 5=nuevo)
            // Simplificación: Leer los 6, encontrar los 4 únicos espaciales.
            
            const uniqueCorners = getUniqueCorners(indices, posAttr); 
            // uniqueCorners es array de 4 Vector3 ordenados (CCW o CW)

            // 2. Calcular vector de extrusión (Normal * Distancia)
            const normal = selection.userData.normal.clone();
            const extrudeVec = normal.multiplyScalar(0.5); // Extrusión inicial pequeña

            // 3. Crear "Tapa" (Nueva cara desplazada)
            const newCapVerts = uniqueCorners.map(v => v.clone().add(extrudeVec));

            // 4. Generar geometría lateral (4 Quads = 8 Tris)
            const newSideTris = [];
            const len = uniqueCorners.length;
            for(let i=0; i<len; i++) {
                const next = (i+1)%len;
                // Base A, Base B, Top A, Top B
                const b1 = uniqueCorners[i];
                const b2 = uniqueCorners[next];
                const t1 = newCapVerts[i];
                const t2 = newCapVerts[next];
                
                // Quad Lateral (2 tris)
                pushQuad(newSideTris, b1, b2, t1, t2);
            }

            // 5. Actualizar la "Tapa" original a la nueva posición
            // Modificamos los vértices existentes en indices para moverlos a la posición de la tapa
            // Pero... necesitamos dejar el hueco? No, movemos la tapa y creamos lados.
            // MEJOR ESTRATEGIA: Mover la cara seleccionada a la nueva posición y AÑADIR los lados.
            
            // Mover vértices existentes (la tapa se desplaza)
            // Necesitamos saber qué índice corresponde a qué esquina.
            // Fuerza bruta: mover cada vértice al newCapVert más cercano.
            indices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(posAttr, idx);
                // Buscar cual de los uniqueCorners era este
                let bestIdx = 0;
                let minDist = Infinity;
                uniqueCorners.forEach((c, ci) => {
                    const d = c.distanceTo(v);
                    if(d < 0.001) bestIdx = ci;
                });
                
                // Asignar nueva posición
                const newPos = newCapVerts[bestIdx];
                oldArray[idx*3] = newPos.x;
                oldArray[idx*3+1] = newPos.y;
                oldArray[idx*3+2] = newPos.z;
            });

            // 6. Añadir los lados al array de geometría
            const finalArray = oldArray.concat(newSideTris);

            updateGeometry(finalArray);
            
            // 7. Auto-seleccionar la nueva cara extruida para seguir trabajando
            // Como rebuildHandles borra todo, necesitamos una forma de trackear.
            // Por ahora, simplemente reconstruimos y dejamos al usuario seleccionar.
            rebuildHandles('face');
            
            // Truco UX: Intentar seleccionar la cara que está donde estaba la normal
            // (Omitido por brevedad, el usuario puede tocarla rápido)
        }

        // INSERTAR (Inset): Crea una cara interna
        function insetFace() {
            if (!selection || selection.userData.type !== 'face') return;
            const indices = selection.userData.indices;
            const posAttr = geometry.attributes.position;
            const oldArray = Array.from(posAttr.array);

            const uniqueCorners = getUniqueCorners(indices, posAttr);
            
            // Calcular centro
            const center = new THREE.Vector3();
            uniqueCorners.forEach(v => center.add(v));
            center.divideScalar(4);

            // Crear anillo interno (contracción)
            const scale = 0.7; // 30% inset
            const innerCorners = uniqueCorners.map(v => {
                return new THREE.Vector3().subVectors(v, center).multiplyScalar(scale).add(center);
            });

            // Generar 4 Quads que forman el marco (Outer -> Inner)
            const newFrameTris = [];
            for(let i=0; i<4; i++) {
                const next = (i+1)%4;
                pushQuad(newFrameTris, uniqueCorners[i], uniqueCorners[next], innerCorners[i], innerCorners[next]);
            }

            // Reemplazar la cara original con la cara interna (más pequeña)
            // Similar a extrude, movemos los vértices existentes hacia adentro
            indices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(posAttr, idx);
                let bestIdx = 0;
                let minDist = Infinity;
                uniqueCorners.forEach((c, ci) => { if(c.distanceTo(v)<0.001) bestIdx = ci; });
                
                const newPos = innerCorners[bestIdx];
                oldArray[idx*3] = newPos.x;
                oldArray[idx*3+1] = newPos.y;
                oldArray[idx*3+2] = newPos.z;
            });

            // Añadir el marco al array (la cara central ya se encogió, el marco rellena el hueco)
            const finalArray = oldArray.concat(newFrameTris);
            updateGeometry(finalArray);
            rebuildHandles('face');
        }

        // BORRAR: Elimina geometría
        function deleteSelection() {
            if (!selection) return;
            const indices = selection.userData.indices; // Índices a borrar
            const posAttr = geometry.attributes.position;
            const src = posAttr.array;
            
            // Crear nuevo array excluyendo los indices seleccionados
            // Ojo: los indices son posiciones en el buffer, no valores
            const indicesSet = new Set(indices);
            const newArr = [];
            
            for(let i=0; i<src.length/3; i++) {
                if(!indicesSet.has(i)) {
                    newArr.push(src[i*3], src[i*3+1], src[i*3+2]);
                }
            }
            
            // Si borramos todo, dejar un triángulo mínimo para no crashear
            if(newArr.length === 0) return;

            updateGeometry(newArr);
            rebuildHandles(currentMode);
        }

        // --- UTILIDADES GEOMÉTRICAS ---

        function getUniqueCorners(indices, posAttr) {
            // Extraer Vector3s
            const verts = indices.map(i => new THREE.Vector3().fromBufferAttribute(posAttr, i));
            // Filtrar duplicados espaciales
            const unique = [];
            verts.forEach(v => {
                if(!unique.some(u => u.distanceTo(v) < 0.001)) unique.push(v);
            });
            // Ordenar angularmente respecto al centro para asegurar orden correcto (CW/CCW)
            // (Asumimos quads convexos simples)
            if(unique.length < 3) return unique;
            
            // Calculo de centro y normal para ordenar
            const center = new THREE.Vector3();
            unique.forEach(u => center.add(u));
            center.divideScalar(unique.length);
            const normal = selection.userData.normal;
            
            // Base para angulos
            const base = new THREE.Vector3().subVectors(unique[0], center).normalize();
            const up = normal;
            const right = new THREE.Vector3().crossVectors(up, base).normalize();

            unique.sort((a, b) => {
                const va = new THREE.Vector3().sub
    
